<!doctype html>
<html lang="en">
<head>
  <title>Avaje</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="shortcut icon" href="/images/favicon.ico">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto|Source+Sans+Pro|Ubuntu|Kalam&display=swap">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/reset.css">
  <link rel="stylesheet" href="/css/site.css">
  <link rel="stylesheet" href="/css/pygments.css">
</head>
<body>

<div class="container">
  <aside id="sidenav">
    <nav class="side scroll">
<ul>
  <li><a href="#overview">Overview</a>
</li>
<li><a href="#why">Why GraalVM native image?</a>
</li>
<li><a href="#avaje-and-graalvm">How do Avaje Libraries help?</a>
</li>
<li><a href="#avaje-config">avaje-config</a>
</li>
<li><a href="#avaje-simple-logger">avaje-simple-logger</a>
</li>
<li><a href="#avaje-http">avaje-http</a>
</li>
<li><a href="#avaje-jsonb">avaje-jsonb</a>
</li>
<li><a href="#considerations">Considerations</a>
</li>

</ul>
<p>&nbsp;</p>
    </nav>
  </aside>
  <article id="main-content">
    <header>
      <nav id="top">
        <div class="breadcrumb"><a href="/">avaje</a><span class="sep">&nbsp;/&nbsp;</span><a href="/graalvm/">graalvm</a><span class="sep">&nbsp;/&nbsp;</span><span class="last">comparison</span></div>
        <ul>
          <li><a href="/" title="home"><i class="fas fa-home"></i></a></li>
          <li><a href="https://discord.gg/Qcqf9R27BR" title="discord server"><i class="fab fa-discord"></i></a></li>
          <li><a onclick="toggleTheme();" title="switch dark light theme"><i class="fas fa-adjust"></i></a></li>
        </ul>
      </nav>
    </header>
    
  <h2>
    Comparing GraalVM native image with JVM
  </h2>
  <p>
    The following charts look at some applications that are built with both a
    traditional JVM and GraalVM native image. As part of the build process they
    build a traditional jvm application as a docker image using a base of
    <code>amazoncorretto:25-al2023-headless</code> and a second docker image
    that uses GraalVM native image with a base of <code>redhat/ubi10-micro:10.0</code>.
  </p>
  <p>
    The applications are deployed into Kubernetes. To perform the comparison
    the k8s deployment switches between the two docker images. In this way
    we are looking to get a reasonable comparison between the two approaches.
  </p>

  <hr>
  <h2 id="tiny">Case: Tiny application, tiny load</h2>
  <p>
    This first comparison is a tiny Helidon 4 application that uses avaje-nima
    to provide a single HTTP endpoint that returns a JSON response. The load
    applied is very light, just 10 requests per second.
  </p>
  <p>
    We swap the k8s deployment between the two docker images to get the comparison
    between GraalVM native image and traditional JVM.
  </p>

  <p>
    <img src="/images/graalvm-tiny-app.png" alt="Tiny app : GraalVM vs JVM" style="max-width:100%;height:auto;">
  </p>
  <h4>notes:</h4>
  <ul>
    <li><b>RSS Memory:</b> We see a reduction in RSS memory from around ~250Mb to ~100Mb.</li>
    <li><b>Heap User Memory:</b> Both are using G1 with <code>MaxHeapSize=400m</code>. With GraalVM
      we are seeing a <a href="#heap-flatter">flatter Heap Used line</a></li>
    <li><b>CPU Startup:</b> We see CPU spikes at JVM startup. Note the scale which is ~0.3 so
    this isn't actually that much CPU here, but is looks really significant because (A)
    there is very little load on this application and (B) Virtual Threads rock </li>
    <li><b>CPU load</b>: It looks like <a href="#vt-rock">Virtual threads rock!</a></li>
    <li><b>Mean Latency:</b> Mean latency ~1ms looks good, pretty even</li>
    <li><b>Max Latency:</b> Not shown but pretty even</li>
  </ul>


  <h2>Case: More load</h2>
  <p>
    For this comparison decent load is applied to an application. The only notable difference
    is that the JVM version is using ZGC rather than G1. The GraalVM version is still using G1.
  </p>

  <p>
    <img src="/images/graalvm-vs-jvm.png" alt="Decent load : GraalVM vs JVM" style="max-width:100%;height:auto;">
  </p>


  <h2>Case: Foo</h2>
  <p>
    For this comparison below there is no synthetically generated even load, and instead
    the application is being used in a more real world manner with varying load. The JVM
    version is using ZGC rather than G1. The GraalVM version is still using G1.
  </p>

  <p>
    <img src="/images/graalvm-crossover.png" alt="Decent load : GraalVM vs JVM" style="max-width:100%;height:auto;">
  </p>

  <hr/>
  <h2 id="general-notes">General notes</h2>

  <h4 id="heap-flatter">Heap used is flatter?</h4>
  <p>
    Not really sure why yet. What we do know is that GraalVM native image includes an optimization
    for object headers that reduces the memory footprint of objects. This option is also available for
    the JVM, but it is not enabled for this comparison. GraalVM is also doing some other build time
    initialization for G1 but I don't know the details.
  </p>
  <p>
    So not sure why the we see the difference there in Heap used yet.
  </p>


  <h4 id="vt-rock">Virtual Threads ROCK!!</h4>
  <p>
    Ignoring the application startup, the CPU usage with both the JVM and GraalVM is amazingly low.
    This application is using Virtual Threads for handling requests and it's IO bound (being a REST
    service doing mostly Postgres database queries). With such a light load, and given the nature of this
    application being IO bound, the CPU usage is very low.
  </p>
  <p>
    These applications are using Helidon 4 and we can't easily swap back to Platform threads for a
    more direct comparison, but we can observe the CPU impressively stay load as request load increases.
  </p>

  <h4 id="no-pgo">GraalVM optimizing well (without needing PGO)</h4>
  <p>
    JVM with C2 JIT compiler does a good job of optimizing code at runtime based on
    actual usage patterns. GraalVM native image does AOT (ahead of time) compilation
    and so doesn't have the same runtime information to optimize code. However GraalVM
    native image does perform a number of optimizations at build time to produce
    efficient native code and thus far it's actually produced code that is just slightly
    better than C2 (which is unexpected).
  </p>
  <p>
    How is this possible? Well GraalVM native image does do some static analysis
    during the build process to identify hot spots in the code and optimize those.
    This static analysis is based on heuristics rather than actual runtime data,
    but it seems to be doing a very good job so far.
  </p>

  <h4 id="streaming-json">GraalVM optimizing streaming JSON endpoint</h4>
  <p>
    There is one interesting observation with a streaming endpoint that returns a stream
    of data as "New Line Delimited JSON" (NDJSON). In this case the GraalVM native image
    is performing significantly better than the JVM version.
  </p>
  <p>
    This endpoint is using Ebean ORM findStream() to return a stream of data from
    Postgres and using avaje-jsonb to serialize each object to JSON as it is read
    from the database. It is not clear yet why GraalVM is performing better here,
    but it may be related to escape analysis and stack allocation optimizations
    that GraalVM is performing.
  </p>


  <p><br><br><br><br><br><br></p>


  </article>
</div>

<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
<script src="/js/site.js"></script>
</body>
</html>
