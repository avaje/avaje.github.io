<!doctype html>
<html lang="en">
<head>
  <title>Avaje</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="shortcut icon" href="/images/favicon.ico">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto|Source+Sans+Pro|Ubuntu|Kalam&display=swap">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/reset.css">
  <link rel="stylesheet" href="/css/site.css">
  <link rel="stylesheet" href="/css/pygments.css">
</head>
<body>

<div class="container">
  <aside id="sidenav">
    <nav class="side scroll">
<ul>
  <li class="top-active">
    <a href="/graalvm" class="x">Overview</a>
  <ul class="nav nav-scroll">
<li><a href="#why">Why GraalVM native image?</a>
</li>
<li><a href="#avaje-and-graalvm">How do Avaje Libraries help?</a>
</li>
<li><a href="#considerations">Considerations</a>
</li>
  </ul>
  </li>

  <li >
    <a href="/graalvm/comparison" >Comparison</a>
  </li>
</ul>

<p>&nbsp;</p>
    </nav>
  </aside>
  <article id="main-content">
    <header>
      <nav id="top">
        <div class="breadcrumb"><a href="/">avaje</a><span class="sep">&nbsp;/&nbsp;</span><span class="last">graalvm</span></div>
        <ul>
          <li><a href="/" title="home"><i class="fas fa-home"></i></a></li>
          <li><a href="https://discord.gg/Qcqf9R27BR" title="discord server"><i class="fab fa-discord"></i></a></li>
          <li><a onclick="toggleTheme();" title="switch dark light theme"><i class="fas fa-adjust"></i></a></li>
        </ul>
      </nav>
    </header>
    
  <h1 id="overview">
    <a href="https://www.graalvm.org/">GraalVM.org</a>
  </h1>

  <hr>
  <h2 id="why">Why GraalVM native image?</h2>
  <p>
    In short, using <a href="https://www.graalvm.org/latest/reference-manual/native-image/">GraalVM native image</a>
    to compile Java applications into native executables has the potential to save CPU and Memory resources and this can
    translate into saving <em>$Money</em> in cloud hosting costs.
  </p>
  <p>
    GraalVM native image achieves this by ahead-of-time compiling the Java
    application into a native executable. This results in faster startup times
    and lower memory consumption compared to traditional JVM-based applications.
  </p>
  <p>
    This means we can see charts like this one below ...
  </p>
  <p>
    <a href="/graalvm/comparison"><img src="/images/graalvm-rollout-memory.png" alt="GraalVM Deployment memory" style="max-width:100%;height:auto;"></a>
  </p>
  <p>
    Have a closer look at <b><a href="/graalvm/comparison">JVM vs GraalVM native image comparison</a></b>.
  </p>


  <h2 id="avaje-and-graalvm">How do Avaje Libraries help?</h2>
  <p>
    Avaje libraries avoid using Reflection, Dynamic proxies and Classpath scanning so they
    are well suited to be used in GraalVM native image applications.
  </p>
  <p>
    Avaje libraries also provide specific support for GraalVM native image where needed.
    For example, avaje-config specifies resource loading for <code>application.properties</code> and
    <code>application.yaml</code> etc.
  </p>

  <table>
    <tbody>
    <tr>
      <td>avaje-config</td>
      <td>
        <p>
          avaje-config is a configuration library that supports GraalVM native image.
          It supports loading configuration from properties and yaml files as well as environment variables,
          system properties and plugins (like <a href="/config#aws-appconfig">AWS AppConfig</a>).
        </p>
      </td>
    </tr>
    <tr>
      <td>avaje-simple-logger</td>
      <td>
        <p>
          avaje-simple-logger is a simple structured JSON logger that is well suited
          to GraalVM native image applications.
        </p>
      </td>
    </tr>
    <tr>
      <td>avaje-http</td>
      <td>
        <p>
          avaje-http generates adapter code for <code>@Controller</code> and also HTTP clients.
          This code generation avoids the need for reflection and dynamic proxies, making it
          perfect for use with GraalVM native image.
        </p>
      </td>
    </tr>
    <tr>
      <td>avaje-jsonb</td>
      <td>
        <p>
          avaje-jsonb is a JSON binding library that uses code generation to create
          serializers and deserializers for Java objects. This approach avoids the need
          for reflection, making it ideal for GraalVM native image.
        </p>
      </td>
    </tr>
    <tr>
      <td>avaje-simple-logger</td>
      <td>
        <p>
          avaje-simple-logger is a simple structured JSON logger that is well suited
          to GraalVM native image applications.
        </p>
      </td>
    </tr>
    </tbody>
  </table>

  <h2 id="considerations">GraalVM Considerations</h2>
  <p>
    While GraalVM native image offers significant benefits, there are some
    considerations to keep in mind:
  </p>
  <ul>
    <li>Not all Java libraries are compatible with GraalVM native image. It's important
      to verify that the libraries you plan to use are supported.</li>
    <li>GraalVM native image may not support all Java features, such as dynamic class loading.
      Ensure that your application does not rely on unsupported features.</li>
    <li>Building a GraalVM native image can be more complex and time-consuming than
      building a traditional Java application. Be prepared for a potentially longer
      build process.</li>
  </ul>


  <p><br><br><br><br><br><br></p>


  </article>
</div>

<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
<script src="/js/site.js"></script>
</body>
</html>
