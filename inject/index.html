<!doctype html>
<html lang="en">
<head>
  <title>Avaje</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="shortcut icon" href="/images/favicon.ico">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto|Source+Sans+Pro|Ubuntu&display=swap">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/reset.css">
  <link rel="stylesheet" href="/css/site.css">
  <link rel="stylesheet" href="/css/pygments.css">
</head>
<body>

<div class="container">
  <aside id="sidenav">
    <nav class="side scroll">
<ul>
<li><a href="#overview">Overview</a>
  <ul>
    <li><a href="#jsr-330">JSR-330</a></li>
    <li><a href="#extensions">Extensions</a></li>
  </ul>
</li>
<li><a href="#quick-start">Quick Start</a>
</li>
<li><a href="#dependency">Dependencies</a>
  <ul>
    <li><a href="#maven">Maven</a></li>
    <li><a href="#gradle">Gradle</a></li>
  </ul>
</li>
<li><a href="#jpms">Java Modules</a>
</li>
<li><a href="#generated">Generated Sources</a>
</li>
<li><a href="#injection">Injection</a>
  <ul>
    <li><a href="#singleton">@Singleton</a></li>
    <li><a href="#component">@Component</a></li>
    <li><a href="#import">@Component.Import</a></li>
    <li><a href="#inject">@Inject</a></li>
    <li><a href="#constructor">Constructor Injection</a></li>
    <li><a href="#field">Field Injection</a></li>
    <li><a href="#method">Method Injection</a></li>
    <li><a href="#circular">Circular Dependencies</a></li>
    <li><a href="#optional">Optional</a></li>
    <li><a href="#nullable">Nullable</a></li>
    <li><a href="#list">List and Set</a></li>
    <li><a href="#provider">Provider</a></li>
    <li><a href="#factory">@Factory</a></li>
    <li><a href="#bean">@Bean</a></li>
    <li><a href="#primary">@Primary</a></li>
    <li><a href="#secondary">@Secondary</a></li>
    <li><a href="#prototype">@Prototype</a></li>
  </ul>
</li>
<li><a href="#qualifiers">Qualifiers</a>
  <ul>
    <li><a href="#named">@Named</a></li>
    <li><a href="#qualifier">@Qualifier</a></li>
    <li><a href="#qualifiedmap">@QualifiedMap</a></li>
  </ul>
</li>
<li><a href="#lifecycle">Lifecycle</a>
  <ul>
    <li><a href="#post-construct">@PostConstruct</a></li>
    <li><a href="#pre-destroy">@PreDestroy</a></li>
    <li><a href="#auto-closeable">AutoCloseable</a></li>
  </ul>
</li>
<li><a href="#conditional">Conditional Beans</a>
  <ul>
    <li><a href="#requirebean">@RequiresBean</a></li>
    <li><a href="#requireprops">@RequiresProperty</a></li>
    <li><a href="#profile">@Profile</a></li>
  </ul>
</li>
<li><a href="#aop">AOP</a>
  <ul>
    <li><a href="#aspect">@Aspect</a></li>
  </ul>
</li>
<li><a href="#scope">Scope</a>
  <ul>
    <li><a href="#default-scope">Default Scope</a></li>
    <li><a href="#scope-test-scope">Test Scope</a></li>
    <li><a href="#request-scope">Request Scope</a></li>
    <li><a href="#custom-scope">Custom Scope</a></li>
    <li><a href="#bean-scope">BeanScope</a></li>
  </ul>
</li>
<li><a href="#modules">Modules</a>
  <ul>
    <li><a href="#single-module">Single Module</a></li>
    <li><a href="#multi-module">Multi-module</a></li>
    <li><a href="#shading">Shading Note</a></li>
    <li><a href="#inject-module">@InjectModule</a></li>
  </ul>
</li>
<li><a href="#plugins">Plugins</a>
</li>
<li><a href="#testing">Testing</a>
  <ul>
    <li><a href="#unit-testing">Unit Testing</a></li>
  </ul>
</li>
<li><a href="#component-testing">Component Testing</a>
  <ul>
    <li><a href="#test-dependency">Dependency</a></li>
    <li><a href="#inject-test">@InjectTest</a></li>
    <li><a href="#test-setup">@Setup</a></li>
    <li><a href="#test-qualifier">@Named/@Qualifier</a></li>
    <li><a href="#test-static">Static/Instance Fields</a></li>
    <li><a href="#test-scope">@TestScope</a></li>
    <li><a href="#programmatic-testing">Programmatic Testing</a></li>
  </ul>
</li>
<li><a href="#why">Why avaje-inject exists?</a>
  <ul>
    <li><a href="#why-history">Short history of DI</a></li>
    <li><a href="#why-comparison">Comparison to other DI</a></li>
  </ul>
</li>
<li><a href="#http">http servers</a>
  <ul>
    <li><a href="#http-javalin">Javalin</a></li>
    <li><a href="#http-helidon">Helidon SE</a></li>
  </ul>
</li>
<li><a href="#spring">Spring DI</a>
</li>
<li><a href="#value">Why no @Value?</a>
</li>
</ul>
<p>&nbsp;</p>
    </nav>
  </aside>
  <article id="main-content">
    
<header>
  <nav id="top">
    <div class="breadcrumb">
      <a href="/" title="home">avaje</a> &nbsp;&nbsp;/&nbsp;&nbsp;inject
    </div>
    <ul>
      <li><a href="/" title="home"><i class="fas fa-home"></i></a></li>
      <li><a href="https://github.com/avaje/avaje-inject" title="github source"><i class="fab fa-github"></i></a></li>
      <li><a onclick="toggleTheme();" title="switch dark light theme"><i class="fas fa-adjust"></i></a></li>
    </ul>
  </nav>
</header>
<h1 id="overview">Avaje Inject</h1>
<p>
  Fast and light dependency injection library for Java and Kotlin developers.
</p>
<table style="width: 100%;">
  <tr>
    <th>License</th>
    <th>Source</th>
    <th>API Docs</th>
    <th>Issues</th>
    <th>Releases</th>
  </tr>
  <tr>
    <td><a target="_blank" href="https://github.com/avaje/avaje-inject/blob/master/LICENSE">Apache2</a></td>
    <td><a target="_blank" href="https://github.com/avaje/avaje-inject">Github</a></td>
    <td><a target="_blank" href="/apidocs/avaje-inject">Javadoc</a></td>
    <td><a target="_blank" href="https://github.com/avaje/avaje-inject/issues">Github</a></td>
    <td><a href="https://github.com/avaje/avaje-inject/releases"><img src="https://img.shields.io/maven-central/v/io.avaje/avaje-inject.svg?label=Maven%20Central"></a></td>
  </tr>
</table>
<p>&nbsp;</p>

<p>
  Inject leverages Java annotation processing to generate source code for efficient dependency injection.
  By shifting the responsibility of dependency injection from runtime to build time, it significantly enhances the speed of application startup.
  This approach eliminates the need for intensive reflection or classpath scanning, further optimizing performance.
</p>
<p>
  The dependency injection classes are generated source code.
  This allows us to seamlessly incorporate debug breakpoints into the DI code, enabling us to step through the code as if it were manually written.
  We can use existing IDE tools to search where code is called (e.g. Constructors and lifecycle
  methods.)
</p>
<p>
  For a <a href="#why">background on why</a> <em>avaje inject</em> exists and a
  <a href="#why-comparison">quick comparison</a> with other DI libraries such as
  Dagger2, Micronaut, Quarkus and Spring go to - <a href="#why">Why</a>.
</p>

<h3 id="size">DI Library Size</h3>
<table class="basic">
  <tr>
    <td>
      <p>
        Do we care about the size of a DI library? Why is dagger and avaje-inject so much
        smaller?
      </p>
      <p>
        <em>avaje-inject</em> exists with the view that it should be <em>really</em> small and
        provide JSR-330 dependency injection using source code generation.
      </p>
      <p>
        avaje-inject includes:
      </p>
      <ul>
        <li><a href="#jsr-330">JSR-330</a> dependency injection</li>
        <li><a href="#lifecycle">Lifecycle</a> support</li>
        <li><a href="#factory">@Factory + @Bean</a></li>
        <li><a href="#primary">@Primary + @Secondary</a></li>
        <li><a href="#conditional">Conditional Beans</a></li>
        <li><a href="#test-scope">Test scope</a> and component testing</li>
        <li><a href="#aspect">Aspect Oriented Programming</a> around method advice</li>
      </ul>
    </td>
    <td>
      <img src="/images/di-lib-size.png" alt="DI library size comparison">
    </td>
  </tr>
</table>

<h3 id="releases">Releases for javax and jakarta</h3>
<p>
  The move of JEE to the eclipse foundation meant a change in package from <code>javax</code>
  to <code>jakarta</code> for various APIs including JSR-330 dependency injection API.
</p>
<p>
  Today we have the choice of using the <code>javax.inject</code> dependency or using the new
  <code>jakarta.inject</code> dependency.
</p>

<h4>Want to use jakarta.inject?</h4>
<p>
  Use <a href="https://github.com/avaje/avaje-inject/releases">version 9.x</a> of
  avaje-inject with the dependency on <code>jakarta.inject</code>
</p>

<h4>Want to use javax.inject?</h4>
<p>
  Use <a href="https://github.com/avaje/avaje-inject/releases">version 9.x-javax</a> of
  avaje-inject with the dependency on <code>javax.inject</code>.
</p>

<h3 id="jsr-330">Based on JSR-330</h3>
<p>
  avaje inject is based on <a href="http://javax-inject.github.io/javax-inject/api/index.html">JSR-330: Dependency
    Injection for Java</a> - <em>javax.inject / jakarta.inject</em> with some extensions similar to Spring DI.
</p>
<p>
  JSR-330 provides:
</p>
<ul>
  <li><code><a href="#singleton">@Singleton</a></code></li>
  <li><code><a href="#inject">@Inject</a></code></li>
  <li><code><a href="#named">@Named</a> and <a href="#named">@Qualifier</a></code></li>
  <li><code><a href="#scope">@Scope</a></code></li>
</ul>
<p>
  JSR 250 - Common Annotations for the Java provides:
</p>
<ul>
  <li><code><a href="#post-construct">@PostConstruct</a></code></li>
  <li><code><a href="#pre-destroy">@PreDestroy</a></code></li>
</ul>
<p>
  <code>@PostConstruct</code> and <code>@PreDestroy</code> are part of <em>Common Annotations API</em>.
  These were in JDK 8, but from JDK 9 onwards are part of JDK module <em>javax.annotation-api</em>.
</p>
<p>
  Currently, neither Dagger2 or Guice support or plan to support <code>@PostConstruct</code>
  and <code>@PreDestroy</code> lifecycle annotations.
</p>

<h3 id="extensions">DI extensions to JSR-330</h3>

<h4>Component Testing</h4>
<p>
  We use <code><a href="#inject-test">@InjectTest</a></code> for <a href="#component-testing">component testing</a>, similar
  to Spring's <code>@SpringBootTest</code>.
</p>
<p>
  This is where we get avaje-inject to wire the test class using <code>@Inject, @Mock, @Spy</code>.
</p>

<h4>@Factory + @Bean</h4>
<p>
  In addition to the JSR-330 standard, we use <a href="#factory">@Factory</a> + <a href="#bean">@Bean</a>
  which have a similar function as Spring DI's <em>@Configuration + @Bean</em> and also Micronaut's
  <em>@Factory + @Bean</em>. This is also similar to a Guice module with <em>@Provides</em> methods.
</p>
<p>
  Teams will often use <em>@Factory + @Bean</em> to provide dependencies that
  are best created programmatically. Typically, these depend on external configuration,
  environment settings, etc.
</p>
<p>
  Factory provides a more convenient alternative to the JSR-330
  <a href="#provider">javax.inject.Provider&lt;T&gt;</a> interface and is also more natural
  for people who are familiar with Spring DI or Micronaut DI.
</p>

<h4>@Primary + @Secondary</h4>
<p>
  Additionally we use <a href="#primary">@Primary</a> <a href="#secondary">@Secondary</a> annotations
  which work the same as Spring DI's <em>@Primary + @Secondary</em> and also Micronaut DI's
  <em>@Primary + @Secondary</em>. These provide injection priority in the case when multiple injection
  candidates are available.
</p>
<h2 id="quick-start">Quick Start</h2>
<h4>1. Add <em>avaje-inject</em> as a dependency.</h4>
<div class="syntax xml"><div class="highlight"><pre><span></span><span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>io.avaje<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>avaje-inject<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>&#36;{avaje.inject.version}<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</pre></div>
</div>
<h4>2. Add <em>avaje-inject-generator</em> annotation processor as a dependency with <em>provided scope</em>.</h4>

<div class="syntax xml"><div class="highlight"><pre><span></span><span class="c">&lt;!-- Annotation processor --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>io.avaje<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>avaje-inject-generator<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>&#36;{avaje.inject.version}<span class="nt">&lt;/version&gt;</span>
  <span class="nt">&lt;scope&gt;</span>provided<span class="nt">&lt;/scope&gt;</span>
  <span class="nt">&lt;optional&gt;</span>true<span class="nt">&lt;/optional&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</pre></div>
</div>

<h4>3. Create a Bean Class annotated with <code>@Singleton</code></h4>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Example</span> <span class="o">{</span>

 <span class="kd">private</span> <span class="n">DependencyClass</span> <span class="n">d1</span><span class="o">;</span>
 <span class="kd">private</span> <span class="n">DependencyClass2</span> <span class="n">d2</span><span class="o">;</span>

  <span class="c1">// Dependencies must be annotated with singleton,</span>
  <span class="c1">// or else be provided from another class annotated with @Factory</span>
  <span class="kd">public</span> <span class="nf">Example</span><span class="o">(</span><span class="n">DependencyClass</span> <span class="n">d1</span><span class="o">,</span> <span class="n">DependencyClass2</span> <span class="n">d2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">d1</span> <span class="o">=</span> <span class="n">d1</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">d2</span> <span class="o">=</span> <span class="n">d2</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Example factory class:</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Factory</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExampleFactory</span> <span class="o">{</span>
  <span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="n">DependencyClass2</span> <span class="nf">bean</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">DependencyClass2</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<h4>4. Use BeanScope to wire and retrieve the beans and use however you wish..</h4>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="n">BeanScope</span> <span class="n">beanScope</span> <span class="o">=</span> <span class="n">BeanScope</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">build</span><span class="o">()</span>
<span class="n">Example</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">beanScope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Example</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</pre></div>
</div>
<h2 id="dependency">Dependencies</h2>

<h3 id="maven">Maven</h3>
<p>
  See the <a href="#quick-start">quick start example </a>
</p>

<h3 id="gradle">Gradle</h3>
<p>
  See the example at:
  <a href="https://github.com/dinject/examples/blob/master/javalin-gradle-java-basic/build.gradle">examples/javalin-gradle-java-basic/build.gradle</a>
</p>

<h4>Gradle 5.2+</h4>
<p>
  Use Gradle version 5.2 or greater which has better support for annotation processing.
</p>

<h4>Dependencies</h4>
<p>
  Add <em>avaje-inject</em> as an implementation dependency, <em>avaje-inject-generator</em> as
  an annotation processor, and <em>avaje-inject-test</em> as a test dependency.
</p>

<div class="syntax groovy"><div class="highlight"><pre><span></span><span class="n">dependencies</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="n">implementation</span><span class="o">(</span><span class="s1">&#39;io.avaje:avaje-inject:&#36;{inject.version}&#39;</span><span class="o">)</span>
  <span class="n">annotationProcessor</span><span class="o">(</span><span class="s1">&#39;io.avaje:avaje-inject-generator:&#36;{inject.version}&#39;</span><span class="o">)</span>

  <span class="n">testImplementation</span><span class="o">(</span><span class="s1">&#39;io.avaje:avaje-inject-test:&#36;{inject.version}&#39;</span><span class="o">)</span>
  <span class="n">testAnnotationProcessor</span><span class="o">(</span><span class="s1">&#39;io.avaje:avaje-inject-generator:&#36;{inject.version}&#39;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>

<h4>Kotlin KAPT</h4>
<p>
  See example at: https://github.com/dinject/examples/blob/master/basic-di-kotlin-maven/pom.xml
</p>
<p>
  For use with Kotlin we register <em>avaje-inject-generator</em> as a <code>kapt</code> processor
  to the Kotlin compiler rather than <em>annotationProcessor</em>.
</p>
<div class="syntax groovy"><div class="highlight"><pre><span></span><span class="n">dependencies</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="n">implementation</span><span class="o">(</span><span class="s1">&#39;io.avaje:avaje-inject:&#36;{inject.version}&#39;</span><span class="o">)</span>
  <span class="n">kapt</span><span class="o">(</span><span class="s1">&#39;io.avaje:avaje-inject-generator:&#36;{inject.version}&#39;</span><span class="o">)</span>

  <span class="n">testImplementation</span><span class="o">(</span><span class="s1">&#39;io.avaje:avaje-inject-test:&#36;{inject.version}&#39;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>


<h2 id="jpms">Java Module Setup</h2>
<p>
  If using java modules, in the <code>module-info.java</code> we need to:
</p>
<ol>
  <li>Add a <em>requires</em> clause for <em>io.avaje.inject</em></li>
  <li>Add a <em>provides</em> clause for <em>io.avaje.inject.spi.Module</em></li>
</ol>

<h5>Example module-info</h5>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">io.avaje.inject.spi.Module</span><span class="o">;</span>

<span class="n">module</span> <span class="n">org</span><span class="o">.</span><span class="na">example</span> <span class="o">{</span>

  <span class="n">requires</span> <span class="n">io</span><span class="o">.</span><span class="na field">avaje</span><span class="o">.</span><span class="na">inject</span><span class="o">;</span>
  <span class="c1">// you must define the fully qualified class name of the generated classes. if you use an import statement, compilation will fail</span>
  <span class="n">provides</span> <span class="n">Module</span> <span class="n">with</span> <span class="n">org</span><span class="o">.</span><span class="na field">example</span><span class="o">.</span><span class="na">ExampleModule</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
 In the example above, <code>org.example.ExampleModule</code> is generated code typically found in
  <code>target/generated-sources/annotations</code>.
</p>

<h3>External Avaje Dependencies</h3>
<p>
  If your project uses the module system and imports maven dependencies that provide inject </code>Plugin</code>/</code>Module</code> classes,
  you will need to add the <a href="#autoRequires">maven/gradle inject plugin</a> so that the generated DI classes from the dependencies are discovered.
</p>

<h2 id="generated">Generated Sources</h2>

<h3>DI classes</h3>

<p>
DI classes will be generated to call the constructors for annotated type/factory methods.
</p>
<p>
Below is the class generated for the Example class in the above quickstart.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Generated</span><span class="o">(</span><span class="s">&quot;io.avaje.inject.generator&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Example&#36;DI</span>  <span class="o">{</span>

  <span class="cm">/**</span>
<span class="cm">   * Create and register Example.</span>
<span class="cm">   */</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">build</span><span class="o">(</span><span class="n">Builder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">isAddBeanFor</span><span class="o">(</span><span class="n">Example</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
      <span class="k">var</span> <span class="n">bean</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Example</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">DependencyClass</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="s">&quot;!d1&quot;</span><span class="o">),</span> <span class="n">builder</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">DependencyClass2</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="s">&quot;!d2&quot;</span><span class="o">));</span>
      <span class="n">builder</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">bean</span><span class="o">);</span>
      <span class="c1">// depending on the type of bean, callbacks for field/method injection, and lifecycle support will be generated here as well.</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<h3>Generated Wiring Class</h3>
<p>
The inject annotation processor will determine the dependency wiring order of a project and generate a Module class that will wire the beans.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Generated</span><span class="o">(</span><span class="s">&quot;io.avaje.inject.generator&quot;</span><span class="o">)</span>
<span class="nd">@InjectModule</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ExampleModule</span> <span class="kd">implements</span> <span class="n">Module</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="n">Builder</span> <span class="n">builder</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">classes</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="o">{</span>
      <span class="n">org</span><span class="o">.</span><span class="na field">example</span><span class="o">.</span><span class="na field">DependencyClass</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
      <span class="n">org</span><span class="o">.</span><span class="na field">example</span><span class="o">.</span><span class="na field">DependencyClass2</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
      <span class="n">org</span><span class="o">.</span><span class="na field">example</span><span class="o">.</span><span class="na field">Example</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
      <span class="n">org</span><span class="o">.</span><span class="na field">example</span><span class="o">.</span><span class="na field">ExampleFactory</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
    <span class="o">};</span>
  <span class="o">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Creates all the beans in order based on constructor dependencies. The beans are registered</span>
<span class="cm">   * into the builder along with callbacks for field/method injection, and lifecycle</span>
<span class="cm">   * support.</span>
<span class="cm">   */</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">build</span><span class="o">(</span><span class="n">Builder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">builder</span> <span class="o">=</span> <span class="n">builder</span><span class="o">;</span>
    <span class="c1">// create beans in order based on constructor dependencies</span>
    <span class="c1">// i.e. &quot;provides&quot; followed by &quot;dependsOn&quot;</span>
    <span class="n">build_example_ExampleFactory</span><span class="o">();</span>
    <span class="n">build_example_DependencyClass</span><span class="o">();</span>
    <span class="n">build_example_DependencyClass2</span><span class="o">();</span>
    <span class="n">build_example_Example</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="nd">@DependencyMeta</span><span class="o">(</span><span class="nx">type</span> <span class="o">=</span> <span class="s">&quot;org.example.ExampleFactory&quot;</span><span class="o">)</span>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">build_example_ExampleFactory</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">ExampleFactory&#36;DI</span><span class="o">.</span><span class="na">build</span><span class="o">(</span><span class="n">builder</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@DependencyMeta</span><span class="o">(</span><span class="nx">type</span> <span class="o">=</span> <span class="s">&quot;org.example.DependencyClass&quot;</span><span class="o">)</span>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">build_example_DependencyClass</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">DependencyClass&#36;DI</span><span class="o">.</span><span class="na">build</span><span class="o">(</span><span class="n">builder</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@DependencyMeta</span><span class="o">(</span>
      <span class="n">type</span> <span class="o">=</span> <span class="s">&quot;org.example.DependencyClass2&quot;</span><span class="o">,</span>
      <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;org.example.ExampleFactory&#36;DI.build_bean&quot;</span><span class="o">,</span> <span class="c1">// factory method</span>
      <span class="n">dependsOn</span> <span class="o">=</span> <span class="o">{</span><span class="s">&quot;org.example.ExampleFactory&quot;</span><span class="o">})</span> <span class="c1">//factory beans naturally depend on the factory</span>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">build_example_DependencyClass2</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">ExampleFactory&#36;DI</span><span class="o">.</span><span class="na">build_bean</span><span class="o">(</span><span class="n">builder</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@DependencyMeta</span><span class="o">(</span>
      <span class="n">type</span> <span class="o">=</span> <span class="s">&quot;org.example.Example&quot;</span><span class="o">,</span>
      <span class="n">dependsOn</span> <span class="o">=</span> <span class="o">{</span><span class="s">&quot;org.example.DependencyClass&quot;</span><span class="o">,</span> <span class="s">&quot;org.example.DependencyClass2&quot;</span><span class="o">})</span>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">build_example_Example</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Example&#36;DI</span><span class="o">.</span><span class="na">build</span><span class="o">(</span><span class="n">builder</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<h2 id="injection">Injection</h2>

<h3 id="singleton">@Singleton</h3>
<p>
  Put <code>@Singleton</code> on beans that we want dependency injection on.
  These are beans that are created ("wired") by dependency injection and put into the scope.
  They are then available to be injected into other beans.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>
  <span class="o">...</span>
</pre></div>
</div>

<h3 id="component">@Component</h3>
<p>
  <code>@Component</code> is similar to JSR-330 <code>@Singleton</code> except it is <em>avaje-inject</em>
  specific. In general, we prefer to use the JSR-330 standard annotations but there are a couple of cases
  where would choose to use the avaje-inject specific <code>@Component</code> instead.
</p>
<ul>
  <li>A project is using another DI library (for example, Guice) to process the standard
    <code>@Singleton</code> and we want avaje-inject to co-exist but ignore anything annotated with
    <code>@Singleton</code>.
  </li>
  <li>
    A project wants to work with <em>both</em> <code>javax.inject</code> and <code>jakarta.inject</code>
  </li>
</ul>
<p>
  In these cases we may choose to use the <em>avaje-inject</em> specific <code>@Component</code> rather than
  JSR-330 <code>@Singleton</code>.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>
  <span class="o">...</span>
</pre></div>
</div>

<h4>Ignoring <code>@Singleton</code></h4>
<p>
  To get avaje-inject to ignore any classes annotated with <code>@Singleton</code> use:
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@InjectModule</span><span class="o">(</span><span class="nx">ignoreSingleton</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
</pre></div>
</div>
<p>
  With <code>ignoreSingleton = true</code> avaje-inject will ignore <code>@Singleton</code> with the
  view that some other DI library is also being used and is handling those components.
</p>

<h3 id="import">@Component.Import</h3>
<p>
  Put <code>@Component.Import</code> on a class/package-info to create dependency injection on external classes (e.g. mvn dependencies).
  It has the same effect as if the bean was directly annotated by <code>@Component</code>.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Component.Import</span><span class="o">(</span><span class="nx">TeaMaker</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>
  <span class="o">...</span>
</pre></div>
</div>

<h3 id="inject">@Inject</h3>
<p>
  Put <code>@Inject</code> on the constructor that should be used for constructor dependency injection.
</p>
<p>
  If we want to use field injection put the <code>@Inject</code> on the field. The field must not
  be <code>private</code> and must not be <code>final</code> for field injection.
</p>

<h3 id="constructor">Constructor Injection</h3>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Pump</span> <span class="n">pump</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Grinder</span> <span class="n">grinder</span><span class="o">;</span>

  <span class="nd">@Inject</span>
  <span class="kd">public</span> <span class="nf">CoffeeMaker</span><span class="o">(</span><span class="n">Pump</span> <span class="n">pump</span><span class="o">,</span> <span class="n">Grinder</span> <span class="n">grinder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">pump</span> <span class="o">=</span> <span class="n">pump</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">grinder</span> <span class="o">=</span> <span class="n">grinder</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>
  The above CoffeeMaker is using constructor injection. Both a Pump and Ginder will be injected into the
  constructor when the DI creates (or "wires") the CoffeeMaker.
</p>

<h4>Single Constructors</h4>
<p>
  If there is only one constructor, <b>we don't need
  to specify <code>@Inject</code></b>. This includes records and kotlin data classes.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Pump</span> <span class="n">pump</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Grinder</span> <span class="n">grinder</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">CoffeeMaker</span><span class="o">(</span><span class="n">Pump</span> <span class="n">pump</span><span class="o">,</span> <span class="n">Grinder</span> <span class="n">grinder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">pump</span> <span class="o">=</span> <span class="n">pump</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">grinder</span> <span class="o">=</span> <span class="n">grinder</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="n">record</span> <span class="nf">CoffeeMaker</span><span class="o">(</span><span class="n">Pump</span> <span class="n">pump</span><span class="o">,</span> <span class="n">Grinder</span> <span class="n">grinder</span><span class="o">)</span> <span class="o">{}</span>
</pre></div>
</div>
<div class="syntax kotlin"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="k">class</span> <span class="nc">CoffeeMaker</span><span class="p">(</span><span class="k">private</span> <span class="k">val</span> <span class="py">pump</span><span class="p">:</span> <span class="n">Pump</span><span class="p">,</span> <span class="k">private</span> <span class="k">val</span> <span class="py">grinder</span><span class="p">:</span> <span class="n">Grinder</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>

<h3 id="field">Field Injection</h3>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>

  <span class="nd">@Inject</span>
  <span class="n">Pump</span> <span class="n">pump</span><span class="o">;</span>

  <span class="nd">@Inject</span>
  <span class="n">Grinder</span> <span class="n">grinder</span><span class="o">;</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>
  With field injection the <code>@Inject</code> is placed on the field. The field cannot be <code>private</code>
  or <code>final</code>.
</p>
<h4>Constructor injection preferred</h4>
<p>
  Generally there is a preference to use constructor injection over field injection as constructor
  injection:
</p>
<ul>
  <li>Promotes immutability / use of final fields / proper initialisation</li>
  <li>Communicates required dependencies at compile time. Helps when dependencies
    change to keep test code in line.</li>
  <li>Helps identify when there are too many dependencies. Too many constructor
    arguments is a more obvious code smell compared to field injection.
    Promotes single responsibility principal.</li>
</ul>

<h4>Circular dependencies</h4>
<p>
  We use field injection or method injection to handle <a href="#circular">circular dependencies</a>.
  See <a href="#circular">below</a> for more details.
</p>

<h4>Kotlin field injection</h4>
<p>
  For Kotlin we can consider using <em>lateinit</em> on the property with field injection.
</p>
<div class="syntax kotlin"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="k">class</span> <span class="nc">Grinder</span> <span class="p">{</span>

  <span class="nd">@Inject</span>
  <span class="k">lateinit</span> <span class="k">var</span> <span class="py">pump</span><span class="p">:</span> <span class="n">Pump</span>

  <span class="k">fun</span> <span class="nf">grind</span><span class="p">():</span> <span class="n">String</span> <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>

<h3 id="method">Method Injection</h3>
<p>
  For method injection annotate a method with <code>@Inject</code>.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>

  <span class="n">Grinder</span> <span class="n">grinder</span><span class="o">;</span>

  <span class="nd">@Inject</span>
  <span class="kt">void</span> <span class="nf">setGrinder</span><span class="o">(</span><span class="n">Grinder</span> <span class="n">grinder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">grinder</span> <span class="o">=</span> <span class="n">grinder</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="o">...</span>
</pre></div>
</div>


<h3 id="mixed">Mixed constructor, field and method injection</h3>
<p>
  We are allowed to mix constructor, field and method injection. In the below example the Grinder
  is injected into the constructor and the Pump is injected by field injection.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>

  <span class="nd">@Inject</span>
  <span class="n">Pump</span> <span class="n">pump</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Grinder</span> <span class="n">grinder</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">CoffeeMaker</span><span class="o">(</span><span class="n">Grinder</span> <span class="n">grinder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">grinder</span> <span class="o">=</span> <span class="n">grinder</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>
</div>

<h3 id="circular">Circular Dependencies</h3>
<p>
  When we have a circular dependency then we need to use either <a href="#field">field injection</a>
  or <a href="#method">method injection</a> on one of the dependencies.
</p>
<p>
  For example, lets say we have A and B where A depends on B and B depends on A. In this case
  we can't use constructor injection for both A and B like:
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// circular dependency with constructor injection, this will not work!!</span>

<span class="nd">@Singleton</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
  <span class="n">B</span> <span class="n">b</span><span class="o">;</span>
  <span class="n">A</span><span class="o">(</span><span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>       <span class="c1">// constructor for A depends on B</span>
    <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Singleton</span>
<span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
  <span class="n">A</span> <span class="n">a</span><span class="o">;</span>
  <span class="n">B</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>       <span class="c1">// constructor for B depends on A</span>
    <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  With the above circular dependencies for A and B constructor injection, <em>avaje-inject</em>
  cannot determine the order in which to construct the beans. <em>avaje-inject</em> will
  detect this and product a compilation error outlining the beans involved and ask us
  to change to use field injection for one of the dependencies.
</p>
<p>
  We cannot use constructor injection for both A and B, instead we must use
  either field/method injection on either A or B like:
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
  <span class="nd">@Inject</span>   <span class="c1">// use field injection</span>
  <span class="n">B</span> <span class="n">b</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Singleton</span>
<span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
  <span class="n">A</span> <span class="n">a</span><span class="o">;</span>
  <span class="n">B</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  The reason this works is that field/method injection occur after all the
  dependencies are constructed. <em>avaje-inject</em> uses 3 phases to construct a bean scope:
</p>
<ul>
  <li>Phase 1: Construct all the beans in order based on constructor dependencies</li>
  <li>Phase 2: Apply field injection and method injection on all beans</li>
  <li>Phase 3: Execute all <code>@PostConstruct</code> lifecycle methods</li>
</ul>
<p>
  Circular dependencies more commonly occur with more than 2 beans. For example,
  lets say we have A, B and C where:
</p>
<ul>
  <li>A depends on B</li>
  <li>B depends on C</li>
  <li>C depends on A</li>
</ul>
<p>
  With A, B, C above they combine to create a circular dependency. To handle this
  we need to use <a href="#field">field injection</a> or <a href="#method">method injection</a>
  on one of the dependencies.
</p>

<h3 id="optional">Optional</h3>
<p>
  We can use <code>java.util.Optional&lt;T&gt;</code> to inject optional dependencies.
  These are dependencies that might not be provided / might not have an available implementation
  / might only be provided based on configuration (a bit like a feature toggle).
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">class</span> <span class="nc">Pump</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Heater</span> <span class="n">heater</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">widget</span><span class="o">;</span>

  <span class="nd">@Inject</span>
  <span class="n">Pump</span><span class="o">(</span><span class="n">Heater</span> <span class="n">heater</span><span class="o">,</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">widget</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">heater</span> <span class="o">=</span> <span class="n">heater</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">widget</span> <span class="o">=</span> <span class="n">widget</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">pump</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">widget</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">widget</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">doStuff</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<h5>Spring DI Note</h5>
<p>
  Spring users will be familiar with the use of <code>@Autowired(required=false)</code>
  for wiring optional dependencies. With <em>avaje-inject</em> we instead use <code>Optional</code>
  or <code>@Nullable</code> to inject optional dependencies.
</p>

<h3 id="nullable">@Nullable</h3>
<p>
  As an alternative to Optional we can use <code>@Nullable</code> to indicate that a dependency
  is optional / can be null. Any <code>@Nullable</code> annotation can be used, it does not
  matter which package the annotation is in.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">class</span> <span class="nc">Pump</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Heater</span> <span class="n">heater</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Widget</span> <span class="n">widget</span><span class="o">;</span>

  <span class="nd">@Inject</span>
  <span class="nx">Pump</span><span class="o">(</span><span class="nx">Heater</span> <span class="nx">heater</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nx">Widget</span> <span class="nx">widget</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">heater</span> <span class="o">=</span> <span class="n">heater</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">widget</span> <span class="o">=</span> <span class="n">widget</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">pump</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">widget</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">widget</span><span class="o">.</span><span class="na">doStuff</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<h3 id="list">List</h3>
<p>
  We can inject a <code>java.util.List&lt;T&gt;</code> of beans that implement an interface.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CombinedBars</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">bars</span><span class="o">;</span>

  <span class="nd">@Inject</span>
  <span class="kd">public</span> <span class="nf">CombinedBars</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">bars</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">bars</span> <span class="o">=</span> <span class="n">bars</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>
</div>

<h3 id="set">Set</h3>
<p>
  We can inject a <code>java.util.Set&lt;T&gt;</code> of beans that implement an interface.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CombinedBars</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">bars</span><span class="o">;</span>

  <span class="nd">@Inject</span>
  <span class="kd">public</span> <span class="nf">CombinedBars</span><span class="o">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">bars</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">bars</span> <span class="o">=</span> <span class="n">bars</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>
</div>

<h3 id="provider">Provider</h3>
<p>
  A Singleton bean can implement <code>javax.inject.Provider&lt;T&gt;</code> to create a bean to
  be used in injection.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">class</span> <span class="nc">FooProvider</span> <span class="kd">implements</span> <span class="n">Provider</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Bazz</span> <span class="n">bazz</span><span class="o">;</span>

  <span class="n">FooProvider</span><span class="o">(</span><span class="n">Bazz</span> <span class="n">bazz</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">bazz</span> <span class="o">=</span> <span class="n">bazz</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Foo</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// maybe do interesting logic, read environment variables ...</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">BasicFoo</span><span class="o">(</span><span class="n">bazz</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  We can then have another bean that has <code>Provider&lt;T&gt;</code> injected into it.
  It calls <code>get()</code> to get an instance to then use.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">class</span> <span class="nc">UseFoo</span>  <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Provider</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">fooProvider</span><span class="o">;</span>

  <span class="n">UseFoo</span><span class="o">(</span><span class="n">Provider</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">fooProvider</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">fooProvider</span> <span class="o">=</span> <span class="n">fooProvider</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kt">void</span> <span class="nf">doStuff</span><span class="o">()</span> <span class="o">{</span>

    <span class="c1">// get a Foo instance and use it</span>
    <span class="n">Foo</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">fooProvider</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<p>
  When using <code>Provider&lt;T&gt;</code> <code>get()</code> we can get a new instance each time we
  call <code>get()</code>. In the above example, the <code>FooProvider.get()</code> method
  returns a new instance each time <code>get()</code> is called. This is effectively the
  same as <em>Prototype scope</em>.
</p>
<p>
  An alternative to implementing the <code>Provider&lt;T&gt;</code> interface is
  to instead use <code><a href="#factory">@Factory</a></code> and <code><a href="#bean">@Bean</a></code>
  as can be more flexible and convenient.
</p>

<h3 id="factory">@Factory</h3>
<p>
  Factory beans allow us to programmatically creating a bean. Often the logic is based
  on external configuration, environment variables, system properties etc.
</p>
<p>
  We annotate a class with <code>@Factory</code> to tell us that it contains methods
  that create beans. The factory class can itself have dependencies and the methods
  can also have dependencies.
</p>
<p>
  <em>@Factory</em> <em>@Bean</em> are equivalent to Spring DI <em>@Configuration</em> <em>@Bean</em>
  and Micronaut <em>@Factory</em> <em>@Bean</em>. Guice users will see this as similar to Modules with
  <em>@Provides</em> methods.
</p>

<h3 id="bean">@Bean</h3>
<p>
  We annotate methods on the factory class that create a bean with <code>@Bean</code>.
  These methods can have dependencies and will execute in the appropriate order
  depending on the dependencies they require.
</p>

<h4>Example</h4>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Factory</span>
<span class="kd">class</span> <span class="nc">Configuration</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">StartConfig</span> <span class="n">startConfig</span><span class="o">;</span>

  <span class="cm">/**</span>
<span class="cm">   * Factory can have dependencies.</span>
<span class="cm">   */</span>
  <span class="nd">@Inject</span>
  <span class="n">Configuration</span><span class="o">(</span><span class="n">StartConfig</span> <span class="n">startConfig</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">startConfig</span> <span class="o">=</span> <span class="n">startConfig</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Bean</span>
  <span class="n">Pump</span> <span class="nf">buildPump</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// maybe read System properties or environment variables</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">FastPump</span><span class="o">(...);</span>
  <span class="o">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Method with dependencies as method parameters.</span>
<span class="cm">   */</span>
  <span class="nd">@Bean</span>
  <span class="n">CoffeeMaker</span> <span class="nf">buildBar</span><span class="o">(</span><span class="n">Pump</span> <span class="n">pump</span><span class="o">,</span> <span class="n">Grinder</span> <span class="n">grinder</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// maybe read System properties or environment variables</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">CoffeeMaker</span><span class="o">(...);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<h3 id="beanclose">@Bean autocloseable</h3>
<p>
  The avaje annotation processor reads the bean method return types to detect if the bean is an instance of <code>Closeable</code> or <code>AutoCloseable</code>.
  In the case where you are wiring an interface that doesn't implement these types, but the concrete class implements, we can specify <code>autocloseable</code> to inform the processor.
 </p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Factory</span>
<span class="kd">class</span> <span class="nc">Configuration</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="nd">@Bean</span><span class="o">(</span><span class="nx">autocloseable</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
  <span class="n">CoffeeMaker</span> <span class="nf">buildCoffeeMaker</span><span class="o">(</span><span class="n">Pump</span> <span class="n">pump</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">CloseableCoffeeMaker</span><span class="o">(</span><span class="n">pump</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<h3 id="initMethod">@Bean initMethod & destroyMethod</h3>
<p>
  With <code>@Bean</code> we can specify an <code>initMethod</code>
  which will be executed on startup like <code>@PostConstruct</code>.
  Similarly a <code>destroyMethod</code> which execute on shutdown like <code>@PreDestroy</code>.
</p>

<p>
  The CoffeeMaker has the appropriate methods that are executed as part of the lifecycle.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>

  <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// lifecycle executed on start/PostConstruct</span>
  <span class="o">}</span>
  <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// lifecycle executed on shutdown/PreDestroy</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>
<h3 id="optionalBean">Optional @Bean</h3>
<p>
  We can use <code>Optional&lt;T&gt;</code> to indicate that the method produces
  an optional dependency.
</p>
<p>
  Often the dependency is only provided based on external configuration
  a bit like a feature toggle / config toggle. For example, we might do
  this in a CI/CD environment until such time that the dependency is
  always "ON" in all environments and then we change to make the dependency
  not optional.
</p>

<h4>Example - Optional dependency</h4>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Factory</span>
<span class="kd">class</span> <span class="nc">Configuration</span> <span class="o">{</span>

  <span class="cm">/**</span>
<span class="cm">   * Optionally provide MessageQueue.</span>
<span class="cm">   */</span>
  <span class="nd">@Bean</span>
  <span class="n">Optional</span><span class="o">&lt;</span><span class="n">MessageQueue</span><span class="o">&gt;</span> <span class="nf">buildQueue</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(...)</span> <span class="o">{</span> <span class="c1">// maybe read external config etc</span>
      <span class="c1">// Not providing the dependency (kind of like feature toggle)</span>
      <span class="k">return</span> <span class="n">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(...);</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>
<h3 id="useOfFactory">Use of @Factory @Bean</h3>
<p>
  It is good to use <code>@Factory</code> for all the dependencies we want to
  create programmatically. Many teams will have a standard location/package they use to
  put a "configuration factory bean" where all programmatically created dependencies are
  defined as a general approach.
</p>
<p>
  If we see logic in constructors then we typically would try to move that logic to a
  factory bean method and keep the constructors simple. Logic in constructors typically
  makes it harder from a testing perspective.
</p>

<h2 id="primary">@Primary</h2>
<p>
  A bean with <code>@Primary</code> is deemed to be highest priority and will be injected and used
  when it is available. This is functionally the same as Spring and Micronaut <em>@Primary</em>.
</p>
<p>
  There should only ever be <b>one</b> bean implementation marked as <em>@Primary</em> for
  a given dependency.
</p>

<h4>Example</h4>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// Highest priority EmailServer</span>
<span class="c1">// Used when available (e.g. module in the class path)</span>
<span class="nd">@Primary</span>
<span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PreferredEmailSender</span> <span class="kd">implements</span> <span class="n">EmailServer</span> <span class="o">{</span>
  <span class="o">...</span>
</pre></div>
</div>

<h2 id="secondary">@Secondary</h2>
<p>
  A bean with <code>@Secondary</code> is deemed to be lowest priority and will only be injected
  if there are no other candidates to inject. We use <code>@Secondary</code> to indicate a
  "default" or "fallback" implementation that will be superseded by any other available implementation.
</p>
<p>
  This is functionally the same as Spring and Micronaut <em>@Secondary</em>.
</p>
<h4>Example</h4>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// Lowest priority EmailServer</span>
<span class="c1">// Only used if no other EmailServer is available</span>
<span class="nd">@Secondary</span>
<span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultEmailSender</span> <span class="kd">implements</span> <span class="n">EmailServer</span> <span class="o">{</span>
  <span class="o">...</span>
</pre></div>
</div>

<h3 id="primary-usage">Use of @Primary and @Secondary</h3>
<p>
  <code>@Primary</code> and <code>@Secondary</code> are used when there are
  multiple candidates to inject. They provide a "priority" to determine which dependency to
  inject and use when injecting a single implementation and multiple candidates are available
  to inject.
</p>
<p>
  We typically use <em>@Primary</em> and <em>@Secondary</em> when we are
  building multi-module applications. We have multiple modules (jars) that provide implementations.
  We use <em>@Secondary</em> to indicate a "default" or "fallback" implementation to use
  and we use <em>@Primary</em> to indicate the best implementation to use when it is available.
  <em>avaje-inject</em> DI will then wire depending on which modules (jars) are included in the classpath.
</p>

<h3 id="prototype">@Prototype</h3>
<p>When the <em>@Prototype</em> annotation is added to a class/factory bean method, a new instance of the bean will be created each time it is requested or wired.</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Prototype</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Proto</span> <span class="o">{</span>
  <span class="c1">//every time this bean is requested, the constructor is called to provide another instance</span>
  <span class="o">...</span>
  <span class="o">}</span>
</pre></div>
</div>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Factory</span>
<span class="kd">class</span> <span class="nc">ProtoFactory</span> <span class="o">{</span>
  <span class="c1">//every time this bean is requested, the factory method is called to provide another instance</span>
  <span class="nd">@Bean</span>
  <span class="nd">@Prototype</span>
  <span class="n">Example</span> <span class="nf">proto</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Example</span><span class="o">();</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>
<h2 id="qualifiers">Qualifiers</h2>

<h3 id="named">@Named</h3>
<p>
  When we have multiple beans that implement a common interface we can qualify
  which instance to use by specifying <code>@Named</code> on the beans and where
  they are injected. This is a standard part of most Java DI frameworks.
</p>
<p>
  Qualifier names are case insensitive.
</p>
<p>
  Lets say we have a Store interface with multiple implementations. We can have
  multiple implementations with <em>@Named</em> qualifier like the example below.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="nd">@Named</span><span class="o">(</span><span class="s">&quot;blue&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BlueStore</span> <span class="kd">implements</span> <span class="n">Store</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>


<span class="nd">@Singleton</span>
<span class="nd">@Named</span><span class="o">(</span><span class="s">&quot;red&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedStore</span> <span class="kd">implements</span> <span class="n">Store</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>

<p>
  Alternatively if we are creating the instances using <em>@Factory</em> <em>@Bean</em> methods
  we can similarly put <em>@Named</em> on the <em>@Bean</em> methods.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Factory</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StoreFactory</span> <span class="o">{</span>

  <span class="nd">@Bean</span>
  <span class="nd">@Named</span><span class="o">(</span><span class="s">&quot;red&quot;</span><span class="o">)</span>
  <span class="kd">public</span> <span class="n">Store</span> <span class="nf">createRedStore</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">RedStore</span><span class="o">(...);</span>
  <span class="o">}</span>

  <span class="nd">@Bean</span>
  <span class="nd">@Named</span><span class="o">(</span><span class="s">&quot;blue&quot;</span><span class="o">)</span>
  <span class="kd">public</span> <span class="n">Store</span> <span class="nf">createBlueStore</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">BlueStore</span><span class="o">(...);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<p>
  Finally, we can specify the name when explicitly registering a bean with a <code>BeanScope</code>.
</p>

<p>
  We can then specify which <em>@Named</em> instance to inject by specifying the qualifier.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderProcessor</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Store</span> <span class="n">store</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">OrderProcessor</span><span class="o">(</span><span class="nd">@Named</span><span class="o">(</span><span class="s">&quot;red&quot;</span><span class="o">)</span> <span class="nx">Store</span> <span class="nx">store</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">store</span> <span class="o">=</span> <span class="n">store</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="o">...</span>
</pre></div>
</div>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderProcessor</span> <span class="o">{</span>

  <span class="nd">@Inject</span>
  <span class="nd">@Named</span><span class="o">(</span><span class="s">&quot;red&quot;</span><span class="o">)</span>  <span class="c1">// field injection</span>
  <span class="n">Store</span> <span class="n">store</span><span class="o">;</span>

  <span class="o">...</span>
</pre></div>
</div>

<p>
  <code>@Named</code> is a standard part of Java dependency injection frameworks. Avaje Inject goes further and eliminates the need for
  writing out the annotation at all. All injectable parameters or fields that don't specify <code>@Named</code> explicitly are implicitly
  given a name of <code>!name</code>. So the above can be more cleanly written by relying on this implicit rule, like this:
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderProcessor</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Store</span> <span class="n">store</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">OrderProcessor</span><span class="o">(</span><span class="n">Store</span> <span class="n">red</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">store</span> <span class="o">=</span> <span class="n">store</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="o">...</span>
</pre></div>
</div>

<p>
  This type of implicit naming is useful if you want to inject things with a relatively widely used type, for example,
  a <code>java.nio.file.Path</code> object.
</p>

<h3 id="qualifier">@Qualifier</h3>
<p>
  Instead of using <em>@Named</em> we can create our own annotations using <code>@Qualifier</code>.
  This gives a strongly typed approach to qualifying the beans rather than using string literals in
  <em>@Named</em> so could be better when there is a lot of named/qualified beans.
</p>
<h5>example</h5>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">javax.inject.Qualifier</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.annotation.Retention</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.annotation.RetentionPolicy</span><span class="o">;</span>

<span class="nd">@Qualifier</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nx">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nx">Blue</span> <span class="o">{}</span>
</pre></div>
</div>
<p>
  Then we can use our <em>@Blue</em> annotation.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Blue</span>
<span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BlueStore</span> <span class="kd">implements</span> <span class="n">Store</span> <span class="o">{</span>
  <span class="o">...</span>
</pre></div>
</div>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StoreManager</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Store</span> <span class="n">store</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">StoreManager</span><span class="o">(</span><span class="nd">@Blue</span> <span class="nx">Store</span> <span class="nx">store</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">store</span> <span class="o">=</span> <span class="n">store</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="o">...</span>
</pre></div>
</div>


<h3 id="qualifiedmap">@QualifiedMap</h3>
<p>
  To receive a map of beans keyed by qualifier name, we can use <code>@QualifiedMap</code>.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
 <span class="kd">class</span> <span class="nc">CrewMate</span> <span class="o">{</span>

   <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Tasks</span><span class="o">&gt;</span> <span class="n">taskMap</span><span class="o">;</span>

   <span class="nd">@Inject</span>
   <span class="nx">CrewMate</span><span class="o">(</span><span class="nd">@QualifiedMap</span> <span class="nx">Map</span><span class="o">&lt;</span><span class="nx">String</span><span class="o">,</span> <span class="nx">Tasks</span><span class="o">&gt;</span> <span class="nx">taskMap</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">this</span><span class="o">.</span><span class="na">taskMap</span> <span class="o">=</span> <span class="n">taskMap</span><span class="o">;</span>
   <span class="o">}</span>

 <span class="o">}</span>
</pre></div>
</div>
<h2 id="lifecycle">Lifecycle</h2>

<h3 id="post-construct">@PostConstruct</h3>
<p>
  Put <code>@PostConstruct</code> on a method that we want to run on startup just after all the
  beans have been wired.
</p>
<p>
  Typically we open a resource like network connections to a remote resource (cache, queue, database etc).
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>

  <span class="nd">@PostConstruct</span>
  <span class="kt">void</span> <span class="nf">onStartup</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// connect to remote resource ...</span>
    <span class="o">...</span>
  <span class="o">}</span>
  <span class="o">...</span>
</pre></div>
</div>

<h4>@PostConstruct with BeanScope</h3>
<p>
  Since post construct methods execute after all the beans have been wired, we can also add the completed BeanScope as a parameter.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>
  <span class="n">Beans</span> <span class="n">beans</span><span class="o">;</span>

  <span class="nd">@PostConstruct</span>
  <span class="kt">void</span> <span class="nf">onStartup</span><span class="o">(</span><span class="n">BeanScope</span> <span class="n">scope</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">beans</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Beans</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="o">...</span>
</pre></div>
</div>

<h3 id="pre-destroy">@PreDestroy</h3>
<p>
  Put <code>@PreDestroy</code> on a method that we want to run on shutdown.
</p>
<p>
  Typically we want this method to close resources.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>

  <span class="nd">@PreDestroy</span>
  <span class="kt">void</span> <span class="nf">onShutdown</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// close resources</span>
    <span class="o">...</span>
  <span class="o">}</span>

  <span class="nd">@PreDestroy</span><span class="o">(</span><span class="nx">priority</span><span class="o">=</span><span class="mi">20</span><span class="o">)</span> <span class="c1">//default value is 1000</span>
  <span class="kt">void</span> <span class="nf">onShutdownPriority</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// close resources in a specific order</span>
    <span class="o">...</span>
  <span class="o">}</span>
  <span class="o">...</span>
</pre></div>
</div>

<h3 id="auto-closeable">AutoCloseable and Closeable</h3>
<p>
  Both <code>java.lang.AutoCloseable</code> and <code>java.io.Closeable</code> are treated as <em>PreDestroy</em>
  lifecycle methods. Types that implement these interfaces do not need to annotate the <code>close()</code> method,
  it will automatically be treated as if it had a <code>@PreDestroy</code> and executed when the bean scope is closed.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeQueue</span> <span class="kd">implements</span> <span class="n">AutoCloseable</span> <span class="o">{</span>

  <span class="cm">/**</span>
<span class="cm">   * Automatically treated as a PreDestroy method.</span>
<span class="cm">   */</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// close resources</span>
    <span class="o">...</span>
  <span class="o">}</span>
  <span class="o">...</span>
</pre></div>
</div>

<h3 id="shutdownHook">Shutdown hook</h3>
<p>
  When <code>BeanScope</code> is created, we can specify if it should register a JVM shutdown hook.
  This is fired when the JVM is shutdown and this in turn invokes the PreDestroy methods. Otherwise,
  <code>PreDestroy</code> methods are closed when the BeanScope is closed.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="n">BeanScope</span> <span class="n">beanScope</span> <span class="o">=</span>
  <span class="n">BeanScope</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
      <span class="o">.</span><span class="na">shutdownHook</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="c1">// create with JVM shutdown hook</span>
      <span class="o">.</span><span class="na">build</span><span class="o">()</span>
</pre></div>
</div>
<h2 id="conditional">Conditional Beans</h2>

<h3 id="requirebean">@RequiresBean</h3>
<p>
  Put <code>@RequiresBean</code> on a <code>@Factory</code> class, <code>@Factory</code> method,
  or <code>@Singleton</code> class so that a bean will only be registered when the conditions are met.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="nd">@RequiresBean</span><span class="o">(</span><span class="nx">Kindling</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@RequiresBean</span><span class="o">(</span><span class="nx">Cinders</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Fire</span> <span class="o">{</span>
   <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>

<h3 id="requireprops">@RequiresProperty</h3>
<p>
  Put <code>@RequiresProperty</code> on a <code>@Factory</code> class, <code>@Factory</code> method,
  or <code>@Singleton</code> class so that a bean will only be registered when the conditions are met.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="nd">@RequiresProperty</span><span class="o">(</span><span class="s">&quot;unkindled&quot;</span><span class="o">)</span>
<span class="nd">@RequiresProperty</span><span class="o">(</span><span class="nx">value</span> <span class="o">=</span> <span class="s">&quot;fire&quot;</span><span class="o">,</span> <span class="nx">notEqualTo</span> <span class="o">=</span> <span class="s">&quot;burning&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dark</span> <span class="o">{</span>
   <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>

<h3 id="profile">@Profile</h3>
 <p>When the property <code>avaje.profiles</code> is set, we can use <code>@Profile</code> on a <code>@Factory</code> class, <code>@Factory</code> method,
  or <code>@Singleton</code> class so that a bean will only be registered when the given wiring profiles are present/absent.</p>
<p>

</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="nd">@Profile</span><span class="o">(</span><span class="s">&quot;ds2&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BearerOfTheCurse</span> <span class="o">{</span>
   <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>

<h4>PropertyRequiresPlugin</h4>

<p>To test property/profile conditions, an instance of <code>io.avaje.inject.spi.PropertyRequiresPlugin</code> is loaded via <code>java.util.ServiceLoader</code>.

If there are no <code>PropertyRequiresPlugin</code> found, a default implementation will be provided that uses <code>System.getProperty(String)</code> and <code>System.getenv(String)</code>.

<p><a href="https://avaje.io/config/">Avaje Config</a> provides a <code>PropertyRequiresPlugin</code>, so when it's detected in the classpath, it will be used to test the property conditions.

<p>You can provide your own implementation of <code>PropertyRequiresPlugin</code> via service loader if you want to use your own custom testing of property condition.

</p>

<h4>Condition Meta-Annotations</h4>
If multiple beans require the same combination of requirements, you can define a meta-annotation with the requirements:

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@RequiresBean</span><span class="o">(</span><span class="nx">Flame</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@RequiresBean</span><span class="o">(</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">Kindling</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nx">missing</span> <span class="o">=</span> <span class="nx">Dark</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@RequiresProperty</span><span class="o">(</span><span class="nx">value</span> <span class="o">=</span> <span class="s">&quot;flame.state&quot;</span><span class="o">,</span> <span class="nx">notEqualTo</span> <span class="o">=</span> <span class="s">&quot;fading&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nx">FirstFlame</span> <span class="o">{}</span>
</pre></div>
</div>

These annotation can be placed on beans to easily share conditions.

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="nd">@FirstFlame</span>
<span class="nd">@RequiresProperty</span><span class="o">(</span><span class="nx">value</span> <span class="o">=</span> <span class="s">&quot;flame.state&quot;</span><span class="o">,</span> <span class="nx">notEqualTo</span> <span class="o">=</span> <span class="s">&quot;fading&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Light</span> <span class="o">{</span>
   <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>

Additionally, meta annotation can be placed on other meta annotation to easily compose multiple related conditions.

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@FirstFlame</span>
<span class="nd">@RequiresProperty</span><span class="o">(</span><span class="nx">value</span> <span class="o">=</span> <span class="s">&quot;abyss&quot;</span><span class="o">,</span> <span class="nx">equalTo</span><span class="o">=</span><span class="s">&quot;sealed&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nx">AgeOfFire</span> <span class="o">{}</span>
</pre></div>
</div>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="nd">@AgeOfFire</span>
<span class="c1">// AgeOfFire effectively adds the following conditions</span>
<span class="c1">// @RequiresProperty(value = &quot;abyss&quot;, equalTo=&quot;sealed&quot;)</span>
<span class="c1">// @RequiresBean(Flame.class)</span>
<span class="c1">// @RequiresBean(value = Kindling.class, missing = Dark.class)</span>
<span class="c1">// @RequiresProperty(value = &quot;flame.state&quot;, notEqualTo = &quot;fading&quot;)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Sun</span> <span class="o">{</span>
   <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>


<h4>Configuration Requirements</h4>

<p>The conditional annotations are pretty flexible and can be used for a variety of use cases. The following table summarizes some common uses:</p>
<table class="table">
  <tr>
    <th >Requirement</th>
    <th >Example</th>
  </tr>
  <tr>
    <td>One or more beans should be present</td>
    <td><code>@RequiresBean({DataSource.class, DBClient.class})</code></td>
  </tr>
  <tr>
    <td>One or more beans should not be present</td>
    <td><code>@RequiresBean(missing = {DataSource.class, DBClient.class})</code></td>
  </tr>
  <tr>
    <td>Beans with the given names/qualifiers should be present</td>
    <td><code>@RequiresBeans(qualifiers = {"blue", "green"})</code></td>
  </tr>
  <tr>
    <td colspan="3" align="center" style="padding-top:2em;"><i>@PropertyRequires</i></td>
  </tr>
  <tr>
    <td>A given property exists</td>
    <td><code>@RequiresProperty("spinning")</code></td>
  </tr>
  <tr>
    <td>Given properties don't exist</td>
    <td><code>@RequiresProperty(missing = {"spiral","nemesis"})</code></td>
  </tr>
  <tr>
    <td>Given property equals a value</td>
    <td><code>@RequiresProperty(value = "drill", equalTo = "spin-on")</code></td>
  </tr>
  <tr>
    <td>Given property does not equal a value</td>
    <td><code>@RequiresProperty(value = "spirit", notEqualTo = "broken")</code></td>
  </tr>
    <tr>
    <td colspan="3" align="center" style="padding-top:2em;"><i>@Profile</i></td>
  </tr>
  <tr>
    <td>Any of the given profiles are set</td>
    <td><code>@Profile({"sword","bow"})</code></td>
  </tr>
  <tr>
    <td>Given profiles are not set</td>
    <td><code>@Profile(none = {"malice","gloom"})</code></td>
  </tr>
  <tr>
    <td>All the given profiles must be set</td>
    <td><code>@Profile(all = {"light","dragon"})</code></td>
  </tr>
  <tr>
    <td>Given property does not equal a value</td>
    <td><code>@Profile(value = "spirit", notEqualTo = "broken")</code></td>
  </tr>
</table>
<h2 id="aop">Aspect Oriented Programming</h3>
This library has several contructs that support Aspect Oriented Programmming

<h3 id="aspect">@Aspect</h3>
<p>
  Create an annotation class and annotate it with <code>@Aspect</code> to define an aspect annotation.
  To control the execution order of multiple aspects, we can use the ordering property of the <code>@Aspect</code>.
  To import an existing annotation, use <code>@Aspect.Import</code>.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Aspect</span><span class="o">(</span><span class="nx">ordering</span><span class="o">=</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// The default is 1000 so this aspect will execute before others</span>
<span class="nd">@Target</span><span class="o">(</span><span class="nx">ElementType</span><span class="o">.</span><span class="na">METHOD</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nx">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nx">MyAround</span> <span class="o">{</span>

  <span class="n">String</span> <span class="nf">name</span><span class="o">()</span> <span class="k">default</span> <span class="s">&quot;&quot;</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</div>

<p>
For this aspect to work, a corresponding AspectProvider must be wired into the scope.
The AspectProvider should be a <code>@Singleton</code> or <code>@Component</code> that provides a <code>MethodInterceptor</code>.
 (Which will intercept the method call).
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyAroundAspect</span> <span class="kd">implements</span> <span class="n">AspectProvider</span><span class="o">&lt;</span><span class="n">MyAround</span><span class="o">&gt;</span> <span class="o">{</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">MethodInterceptor</span> <span class="nf">interceptor</span><span class="o">(</span><span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">MyAround</span> <span class="n">around</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">ExampleInterceptor</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ExampleInterceptor</span> <span class="kd">implements</span> <span class="n">MethodInterceptor</span> <span class="o">{</span>
    <span class="c1">// MethodInterceptor interception method</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Invocation</span> <span class="n">invoke</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na field">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;before args: &quot;</span> <span class="o">+</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">invoke</span><span class="o">.</span><span class="na">arguments</span><span class="o">())</span> <span class="o">+</span> <span class="s">&quot; method: &quot;</span> <span class="o">+</span> <span class="n">invoke</span><span class="o">.</span><span class="na">method</span><span class="o">());</span>
      <span class="k">try</span> <span class="o">{</span>
        <span class="n">invoke</span><span class="o">.</span><span class="na">invoke</span><span class="o">();</span>
      <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na field">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;after&quot;</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<p>
With the provider set, we can use our newly created aspect annotation on a class/method to intercept calls.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExampleService</span> <span class="o">{</span>

  <span class="nd">@MyAround</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">other</span><span class="o">(</span>
      <span class="n">String</span> <span class="n">param0</span><span class="o">,</span> <span class="kt">int</span> <span class="n">param1</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="s">&quot;other &quot;</span> <span class="o">+</span> <span class="n">param0</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">param1</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<p>
  Avaje will generate a proxy class that will run the aspects for every annotated method.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Proxy</span>
<span class="nd">@Generated</span><span class="o">(</span><span class="s">&quot;io.avaje.inject.generator&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExampleService&#36;Proxy</span> <span class="kd">extends</span> <span class="n">ExampleService</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">MyAroundAspect</span> <span class="n">myAroundAspect</span><span class="o">;</span>

  <span class="kd">private</span> <span class="n">Method</span> <span class="n">other0</span><span class="o">;</span>
  <span class="kd">private</span> <span class="n">MethodInterceptor</span> <span class="n">other0MyAround</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">ExampleService&#36;Proxy</span><span class="o">(</span><span class="n">MyAroundAspect</span> <span class="n">myAroundAspect</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">myAroundAspect</span> <span class="o">=</span> <span class="n">myAroundAspect</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">other0</span> <span class="o">=</span> <span class="n">ExampleService</span><span class="o">.</span><span class="na field">class</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">&quot;other&quot;</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
      <span class="n">other0MyAround</span> <span class="o">=</span> <span class="n">myAroundAspect</span><span class="o">.</span><span class="na">interceptor</span><span class="o">(</span><span class="n">other0</span><span class="o">,</span> <span class="n">other0</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">MyAround</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na field">lang</span><span class="o">.</span><span class="na">String</span> <span class="nf">other</span><span class="o">(</span><span class="n">String</span> <span class="n">param0</span><span class="o">,</span> <span class="kt">int</span> <span class="n">param1</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">call</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Invocation</span><span class="o">.</span><span class="na">Call</span><span class="o">&lt;&gt;(()</span> <span class="o">-&gt;</span> <span class="kd">super</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">param0</span><span class="o">,</span> <span class="n">param1</span><span class="o">))</span>
      <span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">other0</span><span class="o">,</span> <span class="n">param0</span><span class="o">,</span> <span class="n">param1</span><span class="o">);</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">other0MyAround</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">call</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">call</span><span class="o">.</span><span class="na">finalResult</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InvocationException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="n">e</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">InvocationException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<h2 id="default-scope">Default Scope</h2>
<p>
  All beans are instantiated within a <i>scope</i>. Beans annotated with <code>@Singleton</code>
  are in the "default scope".
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">// create all the beans in the &quot;default scope&quot;</span>
    <span class="n">BeanScope</span> <span class="n">scope</span> <span class="o">=</span> <span class="n">BeanScope</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>

    <span class="n">SomeObject</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">SomeObject</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  When avaje-inject builds the "default scope" it will service load all the default scope modules
  in the classpath (i.e. wire all the "default scope" modules in the classpath together into the BeanScope).
</p>

<h2 id="scope-test-scope">Test scope</h2>
<p>
  Test scope is a special scope used for testing. It effectively provides <em>default dependencies to
  use for all tests</em>.
</p>
<p>
  Refer to <a href="#test-scope">Testing - Test Scope</a> for more details.
</p>


<h2 id="request-scope">Request Scope - @Controller</h2>
<p>
  When using <a href="/http">avaje-http</a> we annotate controllers with <code>@Controller</code>.
  <em>avaje-inject</em> will detect when controllers have a request scope dependency and automatically
  make them request scoped.
</p>
<p>
  For the following example, the ContactController has a dependency on Javalin Context. This means this
  controller must use request scope.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// Automatically becomes request scoped</span>
<span class="c1">//  ... because Javalin Context is a dependency</span>
<span class="c1">//  ... controller instantiated per request</span>

<span class="nd">@Controller</span>
<span class="nd">@Path</span><span class="o">(</span><span class="s">&quot;/contacts&quot;</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">ContactController</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">ContactService</span> <span class="n">contactService</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Context</span> <span class="n">context</span><span class="o">;</span> <span class="c1">// Javalin Context</span>

  <span class="c1">// Inject Javalin context via constructor</span>
  <span class="nd">@Inject</span>
  <span class="n">ContactController</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">,</span> <span class="n">ContactService</span> <span class="n">contactService</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">context</span> <span class="o">=</span> <span class="n">context</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">contactService</span> <span class="o">=</span> <span class="n">contactService</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Get</span><span class="o">(</span><span class="s">&quot;/{id}&quot;</span><span class="o">)</span>
  <span class="n">Contact</span> <span class="nf">getById</span><span class="o">(</span><span class="kt">long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// use the javalin context ...</span>
    <span class="k">var</span> <span class="n">fooCookie</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">cookieStore</span><span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">);</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<h2 id="custom-scope">@Scope - custom scopes</h2>
<p>
  We can define our own custom scopes. To do this we create an annotation that is meta-annotated with <code>@Scope</code>.
  We use this custom scope annotation rather than <code>@Singleton</code>.
</p>
<p>
  Custom scopes can depend on each other and also externally defined objects, thus allowing a hierarchy of scopes to be modelled.
</p>
<p>
  Each scope results in the generation of a module class that can be added to a <code>BeanScope</code> using the <code>modules</code> method.
  The constructor of the module class takes the externally defined dependencies if defined. This makes it easy to partially adopt Avaje Inject
  where we want some objects can be built manually by your own code and then provided to the DI scope.
</p>
<p>
  For simple cases we don't need to use custom scopes. We can just annotate classes with <code>@Singleton</code> and
  use the default scope.
</p>

<h3>Example: Custom Scope</h3>

<h5>Step 1: Define the custom scope annotation</h5>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Scope</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nx">MyCustomScope</span> <span class="o">{</span>
<span class="o">}</span>
</pre></div>
</div>

<h5>Step 2: Use the custom scope annotation (rather than @Singleton)</h5>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@MyCustomScope</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SomeObject</span> <span class="o">{</span>

<span class="o">}</span>
</pre></div>
</div>

<h5>Step 3: Build BeanScope with the custom scope</h5>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

    <span class="n">BeanScope</span> <span class="n">scope</span> <span class="o">=</span> <span class="n">BeanScope</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
      <span class="o">.</span><span class="na">modules</span><span class="o">(</span><span class="k">new</span> <span class="n">MyCustomScopeModule</span><span class="o">())</span>
      <span class="o">.</span><span class="na">build</span><span class="o">();</span>

    <span class="n">SomeObject</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">SomeObject</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<h3>Custom Scope Dependencies</h3>
<p>
  Custom scopes can have dependencies on other scopes or externally supplied beans.
  We specify these dependencies using <code>@InjectModule(requires = ...)</code>.
</p>
<p>
  Custom scope beans are allowed to depend on any bean in the "default scope" implicitly. We do not
  need to specify a dependency for custom scoped beans to use default scoped beans.
</p>
<p>
  In the following example <code>MyCustomScope</code> has a dependency on <code>NonDIConstructedObject</code>.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Scope</span>
<span class="nd">@InjectModule</span><span class="o">(</span><span class="nx">requires</span> <span class="o">=</span> <span class="o">{</span><span class="nx">NonDIConstructedObject</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nx">MyCustomScope</span> <span class="o">{</span>
<span class="o">}</span>

<span class="nd">@MyCustomScope</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SomeObject</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nf">SomeObject</span><span class="o">(</span><span class="n">NonDIConstructedObject</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

    <span class="n">BeanScope</span> <span class="n">scope</span> <span class="o">=</span> <span class="n">BeanScope</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
      <span class="c1">// custom module with an external dependency</span>
      <span class="o">.</span><span class="na">modules</span><span class="o">(</span><span class="k">new</span> <span class="n">MyCustomScopeModule</span><span class="o">(</span><span class="k">new</span> <span class="n">NonDIConstructedObject</span><span class="o">()))</span>
      <span class="o">.</span><span class="na">build</span><span class="o">();</span>

    <span class="n">SomeObject</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">SomeObject</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<p>
  To make one scope depend on another, just put the depended-on scope's annotation into the <code>@InjectModule(requires = { .. })</code>
  list, then call the <code>parent</code> method of the <code>BeanScope</code> to chain them together.
</p>

<h3>Custom scope parent child hierarchy</h3>
<p>
  When using custom scopes we can create a hierarchy of scopes. When we create the BeanScope
  we can use <code>parent()</code> to specify a parent scope.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// create a parent scope</span>
<span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="n">BeanScope</span> <span class="n">parentScope</span> <span class="o">=</span> <span class="n">BeanScope</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">build</span><span class="o">())</span> <span class="o">{</span>

  <span class="c1">// we can use this scope</span>
  <span class="kd">final</span> <span class="k">var</span> <span class="n">coffeeMaker</span> <span class="o">=</span> <span class="n">parentScope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">CoffeeMaker</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

  <span class="c1">// external dependency for a custom scope</span>
  <span class="n">LocalExt</span> <span class="n">ext</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LocalExt</span><span class="o">();</span>

  <span class="c1">// create a child scope</span>
  <span class="k">try</span> <span class="o">(</span><span class="n">BeanScope</span> <span class="n">childScope</span> <span class="o">=</span> <span class="n">BeanScope</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">parent</span><span class="o">(</span><span class="n">parentScope</span><span class="o">)</span> <span class="c1">// specify the parent</span>
    <span class="o">.</span><span class="na">modules</span><span class="o">(</span><span class="k">new</span> <span class="n">MyCustomModule</span><span class="o">(</span><span class="n">ext</span><span class="o">))</span> <span class="c1">// the custom scope(s)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">())</span> <span class="o">{</span>

    <span class="c1">// use the child scope</span>
    <span class="o">...</span>

  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>


<h3 id="bean-scope">BeanScope</h3>
<p>
  The methods on BeanScope that we use to obtain beans out of the scope are:
</p>

<h5>get(<em>type</em>)</h5>
<p>
  Return a single bean given the type.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="n">StoreManager</span> <span class="n">storeManager</span> <span class="o">=</span> <span class="n">beanScope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">StoreManager</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">StoreManager</span><span class="o">.</span><span class="na">processOrders</span><span class="o">();</span>
</pre></div>
</div>

<h5>get(<em>type</em>, <em>qualifier</em>)</h5>
<p>
  Return a single bean given the type and qualifier name.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="n">Store</span> <span class="n">blueStore</span> <span class="o">=</span> <span class="n">beanScope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Store</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">&quot;blue&quot;</span><span class="o">);</span>
<span class="n">blueStore</span><span class="o">.</span><span class="na">checkOrders</span><span class="o">();</span>
</pre></div>
</div>

<h5>list(<em>type</em>)</h5>
<p>
  Return the list of beans that implement the interface.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// e.g. register all routes for a web framework</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">WebRoute</span><span class="o">&gt;</span> <span class="n">routes</span> <span class="o">=</span> <span class="n">beanScope</span><span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">WebRoute</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</pre></div>
</div>

<h5>listByAnnotation(<em>annotation type</em>)</h5>
<p>
  Return the list of beans that have an annotation.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// e.g. register all controllers with web a framework</span>
<span class="c1">// .. where Controller is an annotation on the beans</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">controllers</span> <span class="o">=</span> <span class="n">beanScope</span><span class="o">.</span><span class="na">listByAnnotation</span><span class="o">(</span><span class="n">Controller</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</pre></div>
</div>
<p>
The classic use case for this is registering controllers or routes to
 web frameworks like Sparkjava, Javalin, Rapidoid, Helidon, Undertow etc.
</p>

<h5>listByPriority(<em>type</em>)</h5>
<p>
  Return the list of beans that implement the interface sorting by priority.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// e.g. filters that should be applied in @Priority order</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">Filter</span><span class="o">&gt;</span> <span class="n">filters</span> <span class="o">=</span> <span class="n">beanScope</span><span class="o">.</span><span class="na">listByPriority</span><span class="o">(</span><span class="n">Filter</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</pre></div>
</div>

<h4 id="context-builder">BeanScope.builder()</h4>
<p>
  We can programmatically create a BeanScope with the option on providing
  some instances to use as dependencies. Most often we will do this for
  component testing providing mocks, spies etc to be wired into the beans.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// provide dependencies to be wired</span>
<span class="c1">// ... can be real things or test doubles</span>
<span class="n">MyDependency</span> <span class="n">dependency</span> <span class="o">=</span> <span class="o">...</span>

<span class="k">try</span> <span class="o">(</span><span class="n">BeanScope</span> <span class="n">scope</span> <span class="o">=</span> <span class="n">BeanScope</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
  <span class="o">.</span><span class="na">bean</span><span class="o">(</span><span class="n">MyDependency</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">dependency</span><span class="o">)</span>
  <span class="o">...</span>
  <span class="o">.</span><span class="na">build</span><span class="o">())</span> <span class="o">{</span>

  <span class="n">CoffeeMaker</span> <span class="n">coffeeMaker</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">CoffeeMaker</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="n">coffeeMaker</span><span class="o">.</span><span class="na">makeIt</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  See <a href="#testing">Testing</a> for more on wiring with test doubles.
</p>


<h2 id="modules">Modules</h2>
<p>
  To wire all the beans into a scope, <i>avaje-inject</i> generates module classes that run all the constructors/factory methods and adds all beans to the <i>scope</i>.
</p>
<h3 id="single-module">Single Module Apps</h3>
<p>
  When we are wiring dependencies that are all part of a single jar/module then we don't
  really care about <em>module ordering</em>. All the dependencies that are being injected are known and
  provided by the same jar/module or provided externally.
</p>

<h4>requires - external dependency</h4>
<p>
  We use <code>@InjectModule(requires = ...)</code> to specify an external dependency that will
  be programmatically provided.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// at compile time, allow injection of MyExternalDependency</span>
<span class="c1">// ... even though it doesn&#39;t exist in this module</span>
<span class="nd">@InjectModule</span><span class="o">(</span><span class="nx">requires</span> <span class="o">=</span> <span class="nx">MyExternalDependency</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</pre></div>
</div>
<p>
  When compiling the annotation processor checks that dependencies exist or are listed
  in <code>requires</code> (or <code>requiresPackages)</code> meaning that they are
  externally supplied dependencies.
</p>
<p>
  When creating the BeanScope we provide the externally created dependencies using
  <code>bean()</code>. These external dependencies are then injected where needed.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="n">MyExternalDependency</span> <span class="n">myExternal</span> <span class="o">=</span> <span class="o">...;</span>

<span class="c1">// create with an externally provided dependency</span>
<span class="kd">final</span> <span class="n">BeanScope</span> <span class="n">scope</span> <span class="o">=</span> <span class="n">BeanScope</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
  <span class="o">.</span><span class="na">bean</span><span class="o">(</span><span class="n">MyExternalDependency</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">myExternal</span><span class="o">)</span>
  <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</pre></div>
</div>


<h4>ignoreSingleton</h4>
<p>
  We use <code>@InjectModule(ignoreSingleton = true)</code> in order to specify that we want
  avaje-inject to ignore standard JSR-330 <code>@Singleton</code> - with the expectation
  that another DI library (like Guice) is being used and we want avaje-inject to co-exist
  and ignore anything annotated with <code>@Singleton</code>.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@InjectModule</span><span class="o">(</span><span class="nx">ignoreSingleton</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
</pre></div>
</div>
<p>
  When using <code>ignoreSingleton = true</code> we use <a href="#component">@Component</a> instead of
  using <code>@Singleton</code>.
</p>

<h3 id="multi-module">Multi-module Apps</h3>
<p>
  When we are wiring dependencies that span multiple jars/modules then we to provide more
  control over the order in which the modules are wired. We provide this control
  by using <code>@InjectModule</code> and the use of <code>provides</code>, and <code>requires</code>
  or <code>requiresPackages</code>.
</p>

<h4>Example - modular coffee app</h4>
<p>
  See example source at <a href="https://github.com/avaje/avaje-inject-examples/tree/main/modular-coffee-app">avaje-inject-examples / modular-coffee-app</a>
</p>

<h5>module 1 - coffee-heater</h5>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@InjectModule</span><span class="o">(</span><span class="nx">name</span><span class="o">=</span><span class="s">&quot;coffee-heater&quot;</span><span class="o">,</span> <span class="nx">provides</span> <span class="o">=</span> <span class="nx">Heater</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</pre></div>
</div>

<h5>module 2 - coffee-pump</h5>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@InjectModule</span><span class="o">(</span><span class="nx">name</span> <span class="o">=</span> <span class="s">&quot;coffee-pump&quot;</span><span class="o">,</span> <span class="nx">requires</span> <span class="o">=</span> <span class="nx">Heater</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nx">provides</span> <span class="o">=</span> <span class="nx">Pump</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</pre></div>
</div>
<p>
  This module expects <code>Heater</code> to be provided by another module. In effect, the
  coffee-heater module must be wired <em>before</em> this module, and it provides the Heater
  that is required when we wire the coffee-pump module.
</p>

<h5>module 3 - coffee-main</h5>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@InjectModule</span><span class="o">(</span><span class="nx">name</span> <span class="o">=</span> <span class="s">&quot;coffee-main&quot;</span><span class="o">,</span> <span class="nx">requires</span> <span class="o">=</span> <span class="o">{</span><span class="nx">Heater</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nx">Pump</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
</pre></div>
</div>
<p>
  This module expects <code>Heater</code> and <code>Pump</code> to be provided by other module(s).
  It needs other modules to be wired before and for those modules to provide the Heater and Pump.
</p>
<p>
  avaje-inject determines the order in which to wire the modules based on <code>provides, requires</code>. In this example
  it needs to wire the modules in order of: <em>coffee-heater, coffee-pump and then coffee-main</em>.
</p>
<p>
  That is, in a multi-module app avaje-inject creates one BeanScope per module and needs to
  determine the order in which the modules are wired. It does this using the module <em>provides</em>
  and <em>requires</em>. As the modules are wired, the beans from any previously wired modules are
  available to the module being wired.
</p>

<h3>requires vs requiresPackages</h3>
<p>
  We use either <code>requires</code> OR <code>requiresPackages</code>. Using requires is nice in that
  we explicitly list each external dependency that the module requires BUT this can get onerous when this
  is a really large list. In this case we can use <code>requiresPackages</code> instead and that makes
  the assumption that any dependency under those packages will be provided. So using requiresPackages
  is less strict but more practical when there is a lot of module dependencies.
</p>
<p>
  When we use <code>requiresPackages</code> that means that <code>provides</code> can similarly specify
  a class at the top level, and we don't need to list ALL the provided dependencies.
</p>

<h3 id="autorequires" >autoRequires</h3>
<p>
 <em>avaje-inject</em> can also automatically read the classpath/maven dependencies at compile-time to find all the modules and automatically determine the <code>requires</code> dependencies.
 This works fine in most cases, but when you are using the annotation processor with a java 9+ modular project or defined as an annotationProcessorPath in the <code>maven-compiler-plugin</code>, you will need to add the <code>avaje-inject-maven-plugin</code>. (For Gradle, use the <code>avaje-inject-gradle-plugin</code>)
</p>

<div class="syntax xml"><div class="highlight"><pre><span></span><span class="nt">&lt;plugin&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>io.avaje<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>avaje-inject-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>1.2<span class="nt">&lt;/version&gt;</span>
  <span class="nt">&lt;executions&gt;</span>
    <span class="nt">&lt;execution&gt;</span>
      <span class="nt">&lt;phase&gt;</span>process-sources<span class="nt">&lt;/phase&gt;</span>
      <span class="nt">&lt;goals&gt;</span>
        <span class="nt">&lt;goal&gt;</span>provides<span class="nt">&lt;/goal&gt;</span>
      <span class="nt">&lt;/goals&gt;</span>
    <span class="nt">&lt;/execution&gt;</span>
  <span class="nt">&lt;/executions&gt;</span>
<span class="nt">&lt;/plugin&gt;</span>
</pre></div>
</div>

<p>
What this does is generate 2 files in target before the code is compiled: <code>target/avaje-module-provides.txt</code> and <code>target/avaje-plugin-provides.txt</code>

These are the components and plugins provides by all the other modules that exist in the classpath/maven dependencies. The annotation processor then reads the txt files at compile time and will not error if these components are required dependencies (as they are known to be provided by other modules or plugins).


<h3 id="shading">Shading Note</h3>

<p> As avaje uses the <code>ServiceLoader</code> to load Module classes, be sure to have the following configuration set when using the maven shade plugin on multi-module projects.
<div class="syntax xml"><div class="highlight"><pre><span></span><span class="nt">&lt;plugin&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>maven-shade-plugin<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;configuration&gt;</span>
    <span class="nt">&lt;transformers&gt;</span>
      <span class="nt">&lt;transformer</span> <span class="na">implementation=</span><span class="s">&quot;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer&quot;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/transformers&gt;</span>
  <span class="nt">&lt;/configuration&gt;</span>
<span class="nt">&lt;/plugin&gt;</span>
</pre></div>
</div>

<p> This ensures that the <code>META-INF/services</code> files in the shaded dependencies are merged into the UberJar. With all service entries merged, avaje can discover and load all available modules.

<h3 id="inject-module">@InjectModule</h3>

<h4 id="module-name">name</h4>
<p>
  Give the module an explicit name. Otherwise, it is derived from the top level package.
</p>
<h4 id="module-ignoreSingleton">ignoreSingleton</h4>
<p>
  Set this to true in order to specify that we want
  avaje-inject to ignore standard JSR-330 <code>@Singleton</code> with the expectation
  that another DI library (like Guice) is being used and we want avaje-inject to co-exist
  and ignore anything annotated with <code>@Singleton</code>.
</p>

<h4 id="module-provides">provides</h4>
<p>
  List the classes that this module provides. Used to order modules.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@InjectModule</span><span class="o">(</span><span class="nx">name</span> <span class="o">=</span> <span class="s">&quot;feature-toggle&quot;</span><span class="o">,</span> <span class="nx">provides</span><span class="o">=</span><span class="nx">FeatureToggle</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</pre></div>
</div>

<h4 id="module-requires">requires</h4>
<p>
  Defines dependencies that the modules depends on that are provided by another module or manually.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@InjectModule</span><span class="o">(</span><span class="nx">name</span> <span class="o">=</span> <span class="s">&quot;job-system&quot;</span><span class="o">,</span> <span class="nx">requires</span><span class="o">=</span><span class="nx">FeatureToggle</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</pre></div>
</div>
<p>
  In effect this allows the job system components to depend on <code>FeatureToggle</code> with the expectation that
  it will be supplied by another module or supplied manually.
</p>

<h4 id="module-requiresPackages">requiresPackages</h4>
<p>
  If we have a LOT of dependencies provided by another module specifying each of these explicitly in <code>requires</code>
  can get verbose. Instead of doing that we can use <code>requiresPackages</code> to define top level packages, any
  dependency required under top level packages will be expected to be provided by another module.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// anything at or below the package of Feature is provided externally</span>
<span class="nd">@InjectModule</span><span class="o">(</span><span class="nx">name</span> <span class="o">=</span> <span class="s">&quot;job-system&quot;</span><span class="o">,</span> <span class="nx">requiresPackages</span><span class="o">=</span><span class="nx">Feature</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</pre></div>
</div>

<p>
  <em>avaje-inject</em> uses provides, requires, requiresPackages to determine the order in which the modules are created
  and wired. <em>avaje-inject</em> finds all the modules in the classpath (via Service loader) and then orders the modules
  based on provides, requires, requiresPackages. In the example above the "feature-toggle" module must be wired first,
  and then the beans it contains are available when wiring the "job-system".
</p>
<h2 id="plugins">Plugins</h3>

<P>If you want to execute code when creating a bean scope, you can implement the <code>Plugin</code> SPI.
  Typically, a plugin might provide a default dependency via <code>BeanScopeBuilder.provideDefault()</code>.
</p>

<P>Plugins implement the <code>io.avaje.inject.spi.Plugin</code> interface and are found
      and registered via <code>ServiceLoader</code>. This means they have a
      file at <code>src/main/resources/META-INF/services/io.avaje.inject.spi.Plugin</code>
      which contains the fully qualified class name of the implementation.</P>

<p>Below is an example plugin that provides a default ExampleBean instance. </p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">DefaultBeanProvider</span> <span class="kd">implements</span> <span class="n">io</span><span class="o">.</span><span class="na field">avaje</span><span class="o">.</span><span class="na field">inject</span><span class="o">.</span><span class="na field">spi</span><span class="o">.</span><span class="na">Plugin</span> <span class="o">{</span>

  <span class="c1">//this is called at compile time to tell avaje what bean classes (if any) this plugin provides</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">provides</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Class</span><span class="o">&lt;?&gt;[]{</span><span class="n">ExampleBean</span><span class="o">.</span><span class="na">class</span><span class="o">};</span>
  <span class="o">}</span>

  <span class="c1">// this is called at runtime before any beans are wired</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">apply</span><span class="o">(</span><span class="n">BeanScopeBuilder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//you can access the scope&#39;s wiring properties to help configure your plugin</span>
    <span class="k">var</span> <span class="n">props</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">propertyPlugin</span><span class="o">();</span>

    <span class="c1">//provide a default bean</span>
    <span class="n">builder</span><span class="o">.</span><span class="na">provideDefault</span><span class="o">(</span><span class="n">ExampleBean</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">ExampleBean</span><span class="o">::</span><span class="k">new</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<h2 id="testing">Testing</h2>

<h3 id="unit-testing">Unit Testing</h3>
<p>
  When we are <em>unit testing</em> we are focused on the
  thing we want to test (object under test) and it's dependencies.
</p>
<p>
  In the test setup, code will create the thing we are testing (object under test)
  along with it's dependencies.
</p>

<h5>Mockito programmatic style</h5>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// setup</span>
<span class="kd">final</span> <span class="n">Pump</span> <span class="n">pump</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">Pump</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">Grinder</span> <span class="n">grinder</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">Grinder</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">CoffeeMaker</span> <span class="n">coffeeMaker</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CoffeeMaker</span><span class="o">(</span><span class="n">pump</span><span class="o">,</span> <span class="n">grinder</span><span class="o">);</span>

<span class="c1">// act</span>
<span class="n">coffeeMaker</span><span class="o">.</span><span class="na">makeIt</span><span class="o">();</span>

<span class="n">verify</span><span class="o">(</span><span class="n">pump</span><span class="o">).</span><span class="na">pumpSteam</span><span class="o">();</span>
<span class="n">verify</span><span class="o">(</span><span class="n">grinder</span><span class="o">).</span><span class="na">grindBeans</span><span class="o">();</span>
</pre></div>
</div>

<h5>Mockito JUnit5 Extension</h5>
<p>
  Mockito provides a JUnit 5 extension <code>MockitoExtension</code> which can be used
  with JUnit <code>@ExtendWith</code>. With this extension we can annotate fields with
  <code>@Mock</code>, <code>@Spy</code> and <code>@Captor</code>. Again, this is all
  Mockito - no avaje inject is used here.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nx">MockitoExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">CoffeeMakerTest</span> <span class="o">{</span>

  <span class="nd">@Mock</span> <span class="nx">Pump</span> <span class="nx">pump</span><span class="o">;</span>
  <span class="nd">@Mock</span> <span class="nx">Grinder</span> <span class="nx">grinder</span><span class="o">;</span>

  <span class="nd">@Test</span>
  <span class="kt">void</span> <span class="nf">extensionStyle</span><span class="o">()</span> <span class="o">{</span>

    <span class="c1">// setup</span>
    <span class="n">CoffeeMaker</span> <span class="n">coffeeMaker</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CoffeeMaker</span><span class="o">(</span><span class="n">pump</span><span class="o">,</span> <span class="n">grinder</span><span class="o">);</span>

    <span class="c1">// act</span>
    <span class="n">coffeeMaker</span><span class="o">.</span><span class="na">makeIt</span><span class="o">();</span>

    <span class="n">verify</span><span class="o">(</span><span class="n">pump</span><span class="o">).</span><span class="na">pumpSteam</span><span class="o">();</span>
    <span class="n">verify</span><span class="o">(</span><span class="n">grinder</span><span class="o">).</span><span class="na">grindBeans</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  avaje-inject is NOT used in the above unit tests (as expected). We will see below that avaje-inject
  provides a JUnit extension similar to the Mockito one and that uses the Mockito annotations
  <code>@Mock, @Spy, @Captor</code> and also adds <code>@Inject</code>.
</p>




<h2 id="component-testing">Component Testing</h2>
<p>
  Component testing is where we look to run tests that use most of the objects with their real
  behaviour with less mocked / stubbed behaviour. With component testing we are looking to test a scenario / piece
  of functionality with minimal to no mocking.
</p>
<p>
  The rise and adoption of test docker containers has meant that it is now possible to test significant portions
  of an application without mocking or stubbing resources like databases and messaging.
</p>
<ul>
  <li>Often uses test docker containers for databases, message queues etc</li>
  <li>Use Test scope to provide "default" dependencies (e.g. set up to use the local docker containers)</li>
  <li>Get avaje-inject to "wire" the objects used in the test scenario</li>
  <li>Unlike unit tests, test a scenario with little to no mocking or stubbing</li>
</ul>

<h3 id="test-dependency">Dependency</h3>
<p>
  Add <em>avaje-inject-test</em> as a test dependency.
</p>
<div class="syntax xml"><div class="highlight"><pre><span></span><span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>io.avaje<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>avaje-inject-test<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>&#36;{avaje.inject.version}<span class="nt">&lt;/version&gt;</span>
  <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</pre></div>
</div>


<h3 id="inject-test">@InjectTest</h3>
<p>
  avaje-inject provides a JUnit 5 extension via <code>@InjectTest</code>.
  When a test is annotated with <code>@InjectTest</code> then avaje-inject will be used to setup the
  test using <code>@Inject</code> as well as mockito's <code>@Mock, @Spy, @Captor</code>.
</p>
<p>
  With <em>@InjectTest</em> avaje-inject will build a BeanScope will the appropriate mockito
  mocks and spies and inject back into the test the appropriate objects out of the BeanScope.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@InjectTest</span>
<span class="kd">class</span> <span class="nc">CoffeeMakerTest</span> <span class="o">{</span>

  <span class="nd">@Mock</span> <span class="nx">Pump</span> <span class="nx">pump</span><span class="o">;</span>
  <span class="nd">@Mock</span> <span class="nx">Grinder</span> <span class="nx">grinder</span><span class="o">;</span>
  <span class="c1">// Get this OUT of the DI BeanScope</span>
  <span class="nd">@Inject</span> <span class="nx">CoffeeMaker</span> <span class="nx">coffeeMaker</span><span class="o">;</span>
  <span class="c1">//When a field annotated @Inject has an initialized value, it&#39;s wired INTO the DI BeanScope</span>
  <span class="nd">@Inject</span> <span class="nx">BeanService</span> <span class="nx">myTestDouble</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BeanService</span><span class="o">();</span>

  <span class="nd">@Test</span>
  <span class="kt">void</span> <span class="nf">extensionStyle</span><span class="o">()</span> <span class="o">{</span>

    <span class="c1">// act</span>
    <span class="n">coffeeMaker</span><span class="o">.</span><span class="na">makeIt</span><span class="o">();</span>

    <span class="n">verify</span><span class="o">(</span><span class="n">pump</span><span class="o">).</span><span class="na">pumpSteam</span><span class="o">();</span>
    <span class="n">verify</span><span class="o">(</span><span class="n">grinder</span><span class="o">).</span><span class="na">grindBeans</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  The above test using <code>@InjectTest</code> is equivalent to the test below
  that programmatically creates a BeanScope and performs the same test.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">programmaticStyle</span><span class="o">()</span> <span class="o">{</span>

  <span class="k">try</span> <span class="o">(</span><span class="k">var</span> <span class="n">beanScope</span> <span class="o">=</span> <span class="n">TestBeanScope</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">forTesting</span><span class="o">()</span>
    <span class="o">.</span><span class="na">mock</span><span class="o">(</span><span class="n">Pump</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">mock</span><span class="o">(</span><span class="n">Grinder</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">())</span> <span class="o">{</span>

    <span class="n">CoffeeMaker</span> <span class="n">coffeeMaker</span> <span class="o">=</span> <span class="n">beanScope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">CoffeeMaker</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="c1">// act</span>
    <span class="n">coffeeMaker</span><span class="o">.</span><span class="na">makeIt</span><span class="o">();</span>

    <span class="n">verify</span><span class="o">(</span><span class="n">beanScope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Pump</span><span class="o">.</span><span class="na">class</span><span class="o">)).</span><span class="na">pumpSteam</span><span class="o">();</span>
    <span class="n">verify</span><span class="o">(</span><span class="n">beanScope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Grinder</span><span class="o">.</span><span class="na">class</span><span class="o">)).</span><span class="na">grindBeans</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  If we look closely at the test above, we will see the use of <code>TestBeanScope.builder()</code>
  rather than the usual <code>BeanScope.builder()</code>. We use TestBeanScope to automatically use
  the <a href="#test-scope">"test scope"</a> if it exists.
</p>


<h3 id="test-setup">@Setup</h3>
<p>
  We can use a method annotated with <code>@Setup</code> as an alternative to mock annotations to provide mocks to the test bean context.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@InjectTest</span>
<span class="kd">class</span> <span class="nc">Inject_Test</span> <span class="o">{</span>
  <span class="c1">// calls repo and adds hello string</span>
  <span class="nd">@Inject</span>
  <span class="n">Service</span> <span class="n">service</span><span class="o">;</span>

  <span class="n">Repo</span> <span class="n">repoDouble</span><span class="o">;</span>

  <span class="c1">//use setup to add/replace beans in the context before tests</span>
  <span class="nd">@Setup</span>
  <span class="kt">void</span> <span class="nf">setup</span><span class="o">(</span><span class="n">BeanScopeBuilder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">repoDouble</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">Repo</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">when</span><span class="o">(</span><span class="n">repoDouble</span><span class="o">.</span><span class="na">get</span><span class="o">()).</span><span class="na">thenReturn</span><span class="o">(</span><span class="s">&quot;MockedViaSetupMethod&quot;</span><span class="o">);</span>
    <span class="n">builder</span><span class="o">.</span><span class="na">bean</span><span class="o">(</span><span class="n">Repo</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">repoDouble</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@Test</span>
  <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="s">&quot;MockedViaSetupMethod+hello&quot;</span><span class="o">,</span> <span class="n">service</span><span class="o">.</span><span class="na">process</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>


<h3 id="test-qualifier">@Named and @Qualifier</h3>
<p>
  We can use <code>@Named</code> and qualifiers as needed with <em>@Mock, @Spy, and @Inject</em> like below.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Mock</span> <span class="nd">@Blue</span> <span class="nx">Store</span> <span class="nx">blueStore</span><span class="o">;</span>

<span class="nd">@Mock</span> <span class="nd">@Named</span><span class="o">(</span><span class="s">&quot;red&quot;</span><span class="o">)</span> <span class="nx">Store</span> <span class="nx">redStore</span><span class="o">;</span>
</pre></div>
</div>

<h3 id="test-static">Static fields, Instance fields</h3>
<p>
  With <code>@InjectTest</code> we can inject into static fields and non-static fields.
  Under the hood, these map to BeanScopes that are created and used to populate these fields in the tests.
</p>
<h4>static fields - Junit All</h4>
<p>
  With static fields there is an underlying BeanScope that is created and used for all
  tests in the test class. In the example below, the static Foo is in that BeanScope.
</p>
<p>
  This matches Junit5 <em>All</em> - <code>@BeforeAll, @AfterAll</code> etc.
</p>
<p>
  This BeanScope is created and used for all tests that run for that test class. This scope will be
  closed after all tests for the class have been run.
  The "global test scope" (if defined) will be the parent bean scope.
</p>

<h4>non-static fields - Junit Each</h4>
<p>
  For non-static fields, there is a BeanScope that is created for these. In the example
  below Bar and Bazz are in that BeanScope. With the 3 test methods <code>one(), two(), three()</code>
  this BeanScope is created (and closed) for each test so 3 times.
</p>
<p>
  This matches Junit5 <em>Each</em> - <code>@BeforeEach, @AfterEach</code> etc.
</p>
<p>
  This BeanScope is created for each test and closed after that test has been run.
  It can have a parent bean scope of either the "test static scope" if defined for that test, or
  the "global test scope" (if defined).
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@InjectTest</span>
<span class="kd">class</span> <span class="nc">MyTest</span> <span class="o">{</span>

  <span class="kd">static</span> <span class="nd">@Mock</span> <span class="nx">Foo</span> <span class="nx">foo</span><span class="o">;</span>
  <span class="nd">@Mock</span> <span class="nx">Bar</span> <span class="nx">bar</span><span class="o">;</span>
  <span class="nd">@Inject</span> <span class="nx">Bazz</span> <span class="nx">bazz</span><span class="o">;</span>

  <span class="nd">@Test</span>
  <span class="kt">void</span> <span class="nf">one</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">}</span>

  <span class="nd">@Test</span>
  <span class="kt">void</span> <span class="nf">two</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">}</span>

  <span class="nd">@Test</span>
  <span class="kt">void</span> <span class="nf">three</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>
<p>
  The above <code>MyTest</code> runs 3 tests, <code>one(), two(),</code> and <code>three()</code>.

</p>
<p>
  <em>Static Foo field</em> is wired once and the same foo instance would be used for ALL three tests.
</p>
<p>
  <em>Instance Bar, Bazz fields</em> are wired for each of the three tests - they are wired 3 times.
</p>
<p>
  This can be represented by the diagram below. <em>Bar, Bazz</em> are created and injected 3 times.
  <em>Static Foo</em> is created and injected once.
</p>
<p>
  <img src="/images/inject/inject-static-instance.png" width="100%">
</p>
<p>
  &nbsp;
</p>
<p>
  The above test can be programmatically written as below. In the code below, we see:
</p>
<ul>
  <li><em>staticScope</em> that spans all the tests. Created in <code>beforeAll()</code> and closed in <code>afterAll()</code>.</li>
  <li><em>instanceScope</em> that is created in <code>beforeEach()</code> and closed in <code>afterEach()</code></li>
</ul>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">MyTest</span> <span class="o">{</span>

  <span class="c1">// static fields</span>
  <span class="kd">static</span> <span class="nd">@Mock</span> <span class="nx">Foo</span> <span class="nx">foo</span><span class="o">;</span>

  <span class="c1">// instance fields</span>
  <span class="nd">@Mock</span> <span class="nx">Bar</span> <span class="nx">bar</span><span class="o">;</span>
  <span class="nd">@Inject</span> <span class="nx">Bazz</span> <span class="nx">bazz</span><span class="o">;</span>

  <span class="kd">static</span> <span class="n">BeanScope</span> <span class="n">staticScope</span><span class="o">;</span> <span class="c1">// &quot;static forAll&quot; scope</span>
  <span class="n">BeanScope</span> <span class="n">instanceScope</span>    <span class="c1">// &quot;instance forEach&quot; scope</span>

  <span class="nd">@BeforeAll</span>
  <span class="kd">static</span> <span class="kt">void</span> <span class="nf">beforeAll</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">staticScope</span> <span class="o">=</span> <span class="n">TestBeanScope</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">forTesting</span><span class="o">()</span>
        <span class="o">.</span><span class="na">mock</span><span class="o">(</span><span class="n">Foo</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">()</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="n">staticScope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Foo</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@AfterAll</span>
  <span class="kd">static</span> <span class="kt">void</span> <span class="nf">afterAll</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">staticScope</span><span class="o">.</span><span class="na">close</span><span class="o">()</span>
  <span class="o">}</span>

  <span class="nd">@BeforeEach</span>
  <span class="kt">void</span> <span class="nf">beforeEach</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">instanceScope</span> <span class="o">=</span> <span class="n">TestBeanScope</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">parent</span><span class="o">(</span><span class="n">staticScope</span><span class="o">)</span>
        <span class="o">.</span><span class="na">forTesting</span><span class="o">()</span>
        <span class="o">.</span><span class="na">mock</span><span class="o">(</span><span class="n">Bar</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">()</span>
    <span class="n">bar</span> <span class="o">=</span> <span class="n">instanceScope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Bar</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">bazz</span> <span class="o">=</span> <span class="n">instanceScope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Bazz</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@AfterEach</span>
  <span class="kt">void</span> <span class="nf">afterEach</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">instanceScope</span><span class="o">.</span><span class="na">close</span><span class="o">()</span>
  <span class="o">}</span>


  <span class="nd">@Test</span>
  <span class="kt">void</span> <span class="nf">one</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">}</span>

  <span class="nd">@Test</span>
  <span class="kt">void</span> <span class="nf">two</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">}</span>

  <span class="nd">@Test</span>
  <span class="kt">void</span> <span class="nf">three</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<h3 id="test-scope-parent">Parent child hierarchy</h3>
<p>
  When using <code>@InjectTest</code> we get a 3 level parent child hierarchy of <em>BeanScope</em>.
</p>
<ol>
  <li>Global <a href="#test-scope">test scope</a> that spans ALL tests. This is detailed in the next section.</li>
  <li>Static/All BeanScope - when there are static fields to <em>@Inject, @Mock or @Spy</em>.</li>
  <li>Instance/Each BeanScope - when there are instance fields to <em>@Inject, @Mock or @Spy</em>.</li>
</ol>

<h3>All 3 scopes</h3>
<p>
  When we have all 3 scopes they form a parent child hierarchy as per the diagram below. The "global test scope"
  is the parent of the "static/all scope".  The "static/all scope" is the parent of each "instance/each scope".
</p>
<p>
  <img src="/images/inject/inject-parent.png" width="100%">
</p>

<p>&nbsp;</p>
<h3>Only instance fields</h3>
<p>
  When a test only has instance fields with <em>@Inject, @Mock or @Spy</em> then the global test scope (if defined)
  is the parent of the instance/each scopes.
</p>
<p>
  In this case, <code>@InjectTest</code> detects that there are no static fields to wire and will not create a BeanScope for the
  static/all scope.
</p>
<p>
  <img src="/images/inject/inject-parent-onlyinstance.png" width="100%">
</p>

<p>&nbsp;</p>
<h3>Only static fields</h3>
<p>
  When a test only has static fields with <em>@Inject, @Mock or @Spy</em> then the global test scope (if defined)
  is the parent of the static/all scope. This static/all scope is used by all the tests that run.
</p>
<p>
  In this case, <code>@InjectTest</code> detects that there are no instance fields to wire and will not create a BeanScope for
  each instance/each scope.
</p>
<p>
  <img src="/images/inject/inject-parent-onlystatic.png" width="100%">
</p>

<p>&nbsp;</p>
<h2 id="test-scope">@TestScope - global test scope</h2>
<p>
  When we use <code>@TestScope</code> we create a special bean scope used for testing that spans <em>ALL TESTS</em>.
  It effectively provides <em>default dependencies to use for ALL tests</em>. As such we can think of it as the
  "global test scope".
</p>
<p>
  Under the hood, the global test BeanScope is created when junit starts, this test BeanScope holds all the beans
  that we put in <code>@TestScope</code> and this scope is used as the parent BeanScope for <code>@InjectTest</code>
  tests.
</p>
<p>
  <img src="/images/inject/inject-global-test-scope.png" width="100%">
</p>

<h4>Step 1: Add @TestScope</h4>
<p>
  In <code>src/test</code> create a factory bean that we dedicate to creating test scope dependencies.
  Put <code>@TestScope</code> on this factory bean, the beans this factory creates are in our "test scope"
  and will be wired into tests that use <code>@InjectTest</code>.
</p>

<h4>Example - AmazonDynamoDB</h4>
<p>
  In the example below, our application has a dependency on <code>AmazonDynamoDB</code>. For testing
  purposes, we want all tests to <em>default</em> to using a test scoped AmazonDynamoDB instance that we set
  up to use a localstack docker container.
</p>
<p>
  Example:
  <a target="_blank" href="https://github.com/avaje/avaje-inject-examples/blob/main/hello-dynamodb/src/test/java/org/foo/myapp/config/MyTestConfiguration.java">
    avaje-inject-examples - hello-dynamodb - MyTestConfiguration.java
  </a>
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * All beans wired by this factory will be in the &quot;global test scope&quot;.</span>
<span class="cm"> */</span>
<span class="nd">@TestScope</span>
<span class="nd">@Factory</span>
<span class="kd">class</span> <span class="nc">MyTestConfiguration</span> <span class="o">{</span>

  <span class="cm">/**</span>
<span class="cm">   * An &#39;extra&#39; dependency for testing - a docker container running DynamoDB.</span>
<span class="cm">   */</span>
  <span class="nd">@Bean</span>
  <span class="n">LocalstackContainer</span> <span class="nf">dynamoDBContainer</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">LocalstackContainer</span> <span class="n">container</span> <span class="o">=</span> <span class="n">LocalstackContainer</span>
      <span class="o">.</span><span class="na">builder</span><span class="o">(</span><span class="s">&quot;0.14.2&quot;</span><span class="o">)</span>
      <span class="o">.</span><span class="na">services</span><span class="o">(</span><span class="s">&quot;dynamodb&quot;</span><span class="o">)</span> <span class="c1">// e.g. &quot;dynamodb,sns,sqs&quot;</span>
      <span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="n">container</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">container</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Default to using this AmazonDynamoDB instance in our tests.</span>
<span class="cm">   * This client is setup to use the localstack docker container.</span>
<span class="cm">   */</span>
  <span class="nd">@Bean</span>
  <span class="n">AmazonDynamoDB</span> <span class="nf">dynamoDB</span><span class="o">(</span><span class="n">LocalstackContainer</span> <span class="n">container</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">AmazonDynamoDB</span> <span class="n">dynamoDB</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="na">dynamoDB</span><span class="o">();</span>
    <span class="n">createTable</span><span class="o">(</span><span class="n">dynamoDB</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">dynamoDB</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  Any component that has AmazonDynamoDB injected into it, will now have the above AmazonDynamoDB instance
  which is set up to talk to the localstack docker container DynamoDB.
</p>

<h4>Step 2: @InjectTest</h4>
<p>
  Annotation the test class with <code>@InjectTest</code>.
</p>
<p>
  The component tests can inject AmazonDynamoDB directly, or typically inject a component that depends
  on AmazonDynamoDB and these will use "our test scoped AmazonDynamoDB instance".
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@InjectTest</span>
<span class="kd">class</span> <span class="nc">DynamoDbComponentTest</span> <span class="o">{</span>

  <span class="cm">/**</span>
<span class="cm">   * The test scoped instance.</span>
<span class="cm">   */</span>
  <span class="nd">@Inject</span> <span class="nx">AmazonDynamoDB</span> <span class="nx">dynamo</span><span class="o">;</span>

  <span class="cm">/**</span>
<span class="cm">   * More typical, a component that depends on AmazonDynamoDB.</span>
<span class="cm">   */</span>
  <span class="nd">@Inject</span> <span class="nx">MyDynamoClient</span> <span class="nx">client</span><span class="o">;</span>

<span class="o">}</span>
</pre></div>
</div>
<p>
  The "test scoped bean" is by default wired but each test can override this using <code>@Mock</code> or <code>@Spy</code>.
  For that test, the mock or spy is used and wired instead of the "test scoped bean".
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@InjectTest</span>
<span class="kd">class</span> <span class="nc">OtherComponentTest</span> <span class="o">{</span>

  <span class="cm">/**</span>
<span class="cm">   * Use this instance for this test.</span>
<span class="cm">   */</span>
  <span class="nd">@Mock</span> <span class="nx">AmazonDynamoDB</span> <span class="nx">mockDynamo</span><span class="o">;</span>

  <span class="cm">/**</span>
<span class="cm">   * Now wired with mockDynamo for this test.</span>
<span class="cm">   */</span>
  <span class="nd">@Inject</span> <span class="nx">MyDynamoClient</span> <span class="nx">client</span><span class="o">;</span>

<span class="o">}</span>
</pre></div>
</div>

<h4>Purposes of Test scope beans</h4>
<p>
  Test scope beans generally have one of 3 purposes.
</p>
<h5>1. Extra bean</h5>
<p>
  For testing purposes we want to create an <b>extra</b> bean. For example, the LocalStackContainer that starts a docker container.
</p>

<h5>2. Default bean</h5>
<p>
  We want most of the tests to use a bean (the default one we want to use in tests). For example, we want components to
  use the AmazonDynamoDB instance that will talk to the local docker container.
</p>

<h5>3. Replacement</h5>
<p>
  Say we have a remote API (e.g. Rest call to Github). We don't want any component tests to actually make <em>real calls</em>
  to Github. Instead, we want to have a default stub response and have that as the default. This is similar to (2) but more
  that the default is more like a stub test double.
</p>

<p>
  <code>@InjectTest</code> is syntactic sugar for junit5 <code>@ExtendWith(InjectExtension.class)</code>
</p>



<h2 id="programmatic-testing">Programmatic testing</h2>
<p>
  As an alternative to using <em>InjectExtension</em>, we can write component tests programmatically.
  For programmatic style component testing we create a BeanScope and define test doubles that
  we want to use in place of the real things.
</p>

<h3>TestBeanScope.builder()</h3>
<p>
  For tests we should always use <code>TestBeanScope.builder()</code> rather than <code>BeanScope.builder()</code>.
</p>
<p>
  By using <code>TestBeanScope.builder()</code> it will use the global test scope as a parent bean scope - we
  generally always want to do that for tests.
</p>
<p>
  If we never use the global test scope then we can use <code>BeanScope.builder()</code>.
</p>


<h3>forTesting()</h3>
<p>
  With the bean scope builder we use <code>forTesting()</code> to give us extra methods for ease of using
  mockito mocks and spies. Use <code>mock()</code> to specify a dependency to be a Mockito mock.
  Use <code>spy()</code> to get a dependency to be a Mockito spy. We can use <code>bean()</code>
  to supply any sort of test double we like.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">using_mock</span><span class="o">()</span> <span class="o">{</span>

  <span class="k">try</span> <span class="o">(</span><span class="n">BeanScope</span> <span class="n">scope</span> <span class="o">=</span> <span class="n">TestBeanScope</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">forTesting</span><span class="o">()</span>
    <span class="o">.</span><span class="na">mock</span><span class="o">(</span><span class="n">Pump</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">mock</span><span class="o">(</span><span class="n">Grinder</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">())</span> <span class="o">{</span>

    <span class="c1">// act</span>
    <span class="n">CoffeeMaker</span> <span class="n">coffeeMaker</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">CoffeeMaker</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">coffeeMaker</span><span class="o">.</span><span class="na">makeIt</span><span class="o">();</span>

    <span class="n">verify</span><span class="o">(</span><span class="n">pump</span><span class="o">).</span><span class="na">pumpSteam</span><span class="o">();</span>
    <span class="n">verify</span><span class="o">(</span><span class="n">grinder</span><span class="o">).</span><span class="na">grindBeans</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">using_spy</span><span class="o">()</span> <span class="o">{</span>

  <span class="k">try</span> <span class="o">(</span><span class="n">BeanScope</span> <span class="n">context</span> <span class="o">=</span> <span class="n">TestBeanScope</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">forTesting</span><span class="o">()</span>
    <span class="o">.</span><span class="na">spy</span><span class="o">(</span><span class="n">Pump</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">())</span> <span class="o">{</span>

    <span class="n">CoffeeMaker</span> <span class="n">coffeeMaker</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">CoffeeMaker</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="n">coffeeMaker</span><span class="o">).</span><span class="na">isNotNull</span><span class="o">();</span>
    <span class="n">coffeeMaker</span><span class="o">.</span><span class="na">makeIt</span><span class="o">();</span>

    <span class="n">Pump</span> <span class="n">pump</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Pump</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">verify</span><span class="o">(</span><span class="n">pump</span><span class="o">).</span><span class="na">pumpWater</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<h2 id="why">Why avaje inject exists</h2>

<h3 id="why-history">Short History of DI on the JVM</h3>
<p>
  For a short history of DI on the JVM see below and refer to
  <a target="_blank" href="http://picocontainer.com/inversion-of-control-history.html">PicoContainer - inversion of control history</a>
</p>
<ul>
  <li>1998 - Avalon</li>
  <li>2003 - Spring and PicoContainer</li>
  <li>2005 - Guice</li>
  <li>2009 - JSR 330 javax.inject</li>
  <li>2013 - Dagger1</li>
  <li>2015 - Dagger2</li>
  <li>2018 - Micronaut</li>
  <li>2018 - Avaje-Inject (dinject)</li>
  <li>2019 - Quarkus</li>
</ul>
<p>
  Stefano Mazzocchi popularises the term Inversion of Control and the Apache
  <a target="_blank" href="http://picocontainer.com/inversion-of-control-history.html#avalon">Avalon</a>
  project starts.
</p>
<p>
  Spring and PicoContainer lead the initial adoption of DI. Java 5 came out with
  new language features which included annotations and generics which lead to the
  creation of Guice.
</p>
<p>
  In 2009 developers from Spring, Guice, Redhat and some others got together to
  define JSR-330 - dependency injection for Java.
</p>
<p>
  Some Guice developers went on to develop Dagger which was one of the first
  dependency injection libraries that used Java annotation processing to generate code
  for DI. This moved work that was previously done at runtime to build time, which made
  Dagger significantly faster and lighter than Guice. Dagger becomes heavily
  adopted for Android applications.
</p>
<p>
  <em>
  Using Java annotation processing to move dependency injection work from run time
  to build time is common approach by Dagger, Micronaut, avaje-inject and Quarkus.
  </em>
</p>
<p>
  Around 2018, the pain points of using Spring DI with Kubernetes and resource limited
  containers becomes more obvious. Spring heavily relies on classpath scanning, reflection and
  defining dynamic proxies. This makes it relatively slow and hungry for both CPU and
  memory resources. In cloud deployment where we pay for CPU and memory, some developers
  started looking for another approach to DI which moved more (or virtually all) of that
  work to build time using Java annotation processing [as Dagger2 had been doing in the
  Android space for some years].
</p>
<p>
  In 2018, Micronaut and <em>avaje-inject</em> (this library) are released which use
  Java annotation processing to perform most of DI at build time rather than runtime.
  <br>
  In 2019 Quarkus is released which similarly uses Java annotation processing but
  based on CDI.
</p>

<h3 id="why-comparison">Quick comparison to other DI libraries</h3>
<h5>Why not use Dagger2?</h5>
<p>
  Dagger2 is not particularly orientated for server side developers. It has no lifecycle
  support (@PostConstruct + @PreDestroy) and does not have some features that we like from
  Spring DI (@Factory + @Bean, @Primary + @Secondary, conditional wiring, etc.).
</p>
<h5>Why not use Quarkus?</h5>
<p>
  Quarkus comes with a DI implementation based on CDI. If CDI is your thing you'd look
  at Quarkus. Even so, avaje-Inject is a much smaller library that's focused entirely on DI.
</p>
<h5>Why not Micronaut?</h5>
<p>
  Micronaut DI and <em>avaje-inject</em> are both heavily influenced by Spring DI and
  to some extent look pretty similar. avaje-inject has taken a source code generation
  approach for readability and excluded <code>@Value</code> with a preference instead to
  use a simple <a href="/config">avaje-config</a> style approach to external configuration.

  In addition, avaje determines wiring order at compile-time, hence it doesn't need to take time to figure out all the dependency relationships at runtime.
</p>
<p>
  Ultimately, <em>avaje-inject</em> is a relatively tiny library in comparison to Micronaut or Quarkus
  DI and focused on DI alone.
</p>
<h2 id="http">HTTP Servers</h2>
<p>
  <em>avaje-inject</em> is a lightweight DI library that is especially suited to
  building http based services using <a href="https://javalin.io">Javalin</a>
  and <a href="https://helidon.io">Helidon SE/Nima</a>.
</p>
<p>
  We can build rest controllers and target either Javalin or Helidon SE using
  as little or as much of either Javalin or Helidon as we like.
</p>

<h3 id="javalin">Javalin</h3>
<p>
  Create JAX-RS style controllers targeting <a href="https://javalin.io">Javalin</a>.
  Write controller methods that take the Javalin context as a method argument or
  have it injected as a request scoped bean.
</p>
<p>
  See <a href="/http">here</a> for more details.
</p>

<h3 id="helidon">Helidon SE</h3>
<p>
  Create JAX-RS style controllers targeting <a href="https://helidon.io">Helidon SE</a>.
  Write controller methods that take the Helidon server request and/or response as
  method arguments or have them injected into the controller as request scoped beans.
</p>
<p>
  See <a href="/http">here</a> for more details.
</p>

<h2 id="spring">Spring DI</h2>

<h4>@Factory + @Bean</h4>
<p>
  <em>avaje-inject</em> has <a href="#factory">@Factory</a> + <a href="#bean">@Bean</a> which work the
  same as Spring DI's <em>@Configuration + @Bean</em> and also Micronaut's <em>@Factory + @Bean</em>.
</p>

<h4>@Primary @Secondary</h4>
<p>
  <em>avaje-inject</em> has <a href="#primary">@Primary</a> and <a href="#secondary">@Secondary</a>
  annotations which work the same as Spring DI's <em>@Primary @Secondary</em> and also Micronaut
  DI's <em>@Primary @Secondary</em>.
</p>
<p>
  These provide injection precedence in the case of injecting an implementation when multiple
  injection candidates are available.
</p>

<p>&nbsp;</p>
<h4 id="spring-translation">Spring DI translation</h4>
<table class="table">
  <tr>
    <th width="45%">Spring</th>
    <th width="45%">avaje-inject</th>
    <th width="10%">JSR-330</th>
  </tr>
  <tr>
    <td>@Component, @Service, @Repository</td>
    <td><a href="#singleton">@Singleton</a></td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>FactoryBean&lt;T&gt;</td>
    <td><a href="#provider">Provider&lt;T&gt;</a></td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>@Inject, @Autowired</td>
    <td><a href="#inject">@Inject</a></td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>@Autowired(required=false)</td>
    <td><a href="#optional">@Inject Optional&lt;T&gt;</a></td>
    <td>-</td>
  </tr>
  <tr>
    <td>@PostConstruct</td>
    <td><a href="#post-construct">@PostConstruct</a></td>
    <td>JSR 250</td>
  </tr>
  <tr>
    <td>@PreDestroy</td>
    <td><a href="#pre-destroy">@PreDestroy</a></td>
    <td>JSR 250</td>
  </tr>
  <tr>
    <td colspan="3" align="center" style="padding-top:2em;"><i>Non standard extensions to JSR-330</i></td>
  </tr>
  <tr>
    <td>@Configuration @Bean</td>
    <td><a href="#factory">@Factory @Bean</a></td>
    <td><b>No</b></td>
  </tr>
  <tr>
    <td>@Conditional</td>
    <td><a href="#conditional">@RequiresBean and @RequiresProperty</a></td>
    <td><b>No</b></td>
  </tr>
  <tr>
    <td>@Primary</td>
    <td><a href="#primary">@Primary</a></td>
    <td><b>No</b></td>
  </tr>
  <tr>
    <td>@Profile</td>
    <td><a href="#profile">@Profile</a></td>
    <td><b>No</b></td>
  </tr>
  <tr>
    <td>@Secondary</td>
    <td><a href="#secondary">@Secondary</a></td>
    <td><b>No</b></td>
  </tr>
</table>

<p>&nbsp;</p>
<p>&nbsp;</p>
<h4>Spring DI translation <em>NOT</em> part of avaje-inject</h4>
<table class="table">
  <tr>
    <th width="45%">Spring</th>
    <th width="45%">Other</th>
    <th width="10%"></th>
  </tr>
  <tr>
    <td>@Value</td>
    <td><a href="https://avaje.io/config/">avaje-config</a></td>
    <td></td>
  </tr>
  <tr>
    <td>@Controller</td>
    <td><a href="/http/#controller">avaje-http @Controller</a></td>
    <td></td>
  </tr>
  <tr>
    <td>@Transactional</td>
    <td><a href="https://ebean.io/docs/transactions/">Ebean @Transactional</a></td>
    <td></td>
  </tr>
</table>


<h2 id=value>Why we don't have @Value/Refreshable Scopes</h2>
<p>
  Both Spring and Micronaut have a <code>@Value</code> and by implication, they have chosen to combine "external configuration" in with "dependency injection".
  With avaje-inject a design decision was made to keep these two ideas separate.

  In theory we could have implemented this via source code generation with avaje-inject as:
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EngineImpl&#36;Proxy</span> <span class="kd">extends</span> <span class="n">EngineImpl</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="nf">EngineImpl&#36;Proxy</span><span class="o">()</span> <span class="o">{</span> <span class="c1">// match super constructor,</span>
    <span class="kd">super</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">cylinders</span> <span class="o">=</span> <span class="n">Config</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="s">&quot;my.engine.cylinders&quot;</span><span class="o">,</span> <span class="mi">6</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<p>
  Our reasons for not implementing are as follows.
</p>

<h3>Timing of setting the configuration</h3>
<p>
  We can see that <code>cylinders</code> is only set after the <code>super()</code>.
  Any code that tries to use <code>cylinders</code> before that would get a 0 (or null with Integer etc).
  This is relatively obvious to experienced devs but it is a source of bugs for less experienced devs.
  That is, <code>@Value</code> fields have delayed initialization and this can trip people up / be a source of bugs.
 </p>

 <p>
  If we don't use <code>@Value</code> and use <code>Config.getInt()</code> directly on the field, the behavior is completly unambiguous.
  The values are initialized like any normal field.
</p>

<h3>Dynamic Configuration</h3>
<p>
 With avaje-inject we create an effectively immutable BeanScope because we expect "external dynamic configuration" to be done independently from Dependency Injection (for example, by using avaje-config).

 If we go from needing the configuration read and set <i>once at startup</i> to being read each time and potentially changing (aka dynamic configuration).
 Then we'd need to change away from using <code>@Value</code> or add a complex "Refreshable Scope" concept to this llibrary.
</p>

<p>
When using <code>Config.getInt()</code> directly, there is more freedom. We can use it anywhere - field, final field, static final field, in a method (dynamic configuration).
There isn't a big shift between static configuration and dynamic configuration.
</p>

<h3>Freedom</h3>

<p>
  We have an excellent configuration library in <a href="https://avaje.io/config/">avaje-config</a>.
  It's simple, extendable, and mature as it was originally part of Ebean ORM and was extracted into it's own project.
</p>

<p>
  Even so, we want to give our users the freedom to choose whatever they like with external configuration libraries.
  If we supported <code>@Value</code> in avaje-inject then we would have to pick a "configuration implementation" and force our avaje-config dependency where it's potentially unwanted.
</p>
<p>&nbsp;</p>
<p>&nbsp;</p>





  </article>
</div>

<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
<script src="/js/site.js"></script>
</body>
</html>
